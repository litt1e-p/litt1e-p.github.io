<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[litt1e-p]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="https://litt1e-p.github.io/"/>
  <updated>2020-02-26T11:03:49.120Z</updated>
  <id>https://litt1e-p.github.io/</id>
  
  <author>
    <name><![CDATA[litt1e-p]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Download files in wechat]]></title>
    <link href="https://litt1e-p.github.io/2019/02/26/Download-files-in-wechat/"/>
    <id>https://litt1e-p.github.io/2019/02/26/Download-files-in-wechat/</id>
    <published>2019-02-26T03:43:49.000Z</published>
    <updated>2020-02-26T11:03:49.120Z</updated>
    <content type="html"><![CDATA[<h2 id="在企业微信网页里触发文件下载及兼容性问题">在企业微信网页里触发文件下载及兼容性问题</h2><p>在企业微信自定义网页开发文件预览功能时，官方提供了<code>wx.previewFile</code>接口可以实现。原理是<code>下载-&gt;本地预览</code>。不过对接官方的接口需要一系列的注册申请等操作，给的时间极短，直接触发文件下载应该是可行的。</p>
<p>首先考虑文件的类型，有常见的jpg/png图片和pdf，这两类都很常见，可以直接渲染或者使用pdfjs等一些插件预览，问题不大。比较麻烦的是还有Office类的word、excel、ppt等，直接触发网页下载了。</p>
<p>先判断一下文件类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.getExt = <span class="function"><span class="keyword">function</span> (<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> filename.substring(filename.lastIndexOf(<span class="string">'.'</span>) + <span class="number">1</span>, filename.length) || filename</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道，一般触发浏览器下载的方法有好几种。先试试<code>a</code>元素超链接下载：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">attachments (url = <span class="string">''</span>, attachName = <span class="string">''</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!url) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$message.error(<span class="string">'附件参数有误'</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ([<span class="string">'pdf'</span>, <span class="string">'jpg'</span>, <span class="string">'png'</span>, <span class="string">'bmp'</span>, <span class="string">'gif'</span>, <span class="string">'webp'</span>].includes(fileName.getExt())) &#123;</span><br><span class="line">    <span class="keyword">this</span>.preview(url, attachName)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.download(url, attachName)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">download (url = <span class="string">''</span>, attachName) &#123;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>)</span><br><span class="line">  <span class="keyword">let</span> src = <span class="string">`<span class="subst">$&#123;window.location.origin&#125;</span><span class="subst">$&#123;url&#125;</span>`</span></span><br><span class="line">  el.download = attachName</span><br><span class="line">  el.href = src</span><br><span class="line">  el.click()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写完测试一看。不管是iOS还是android，都可以提示下载，但都下载失败…</p>
<p>再试试iframe下载：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">download (url = <span class="string">''</span>, attachName = <span class="string">''</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</span><br><span class="line">  iframe.style.display = <span class="string">'none'</span></span><br><span class="line">  iframe.src = url</span><br><span class="line">  <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].appendChild(iframe)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再用微信试试打开附件，结果：android可以弹出下载并可以调用手机的app进行预览，但是iOS却仍然毫无反应。为啥？难道要用<code>blob</code>下载?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">download(url = <span class="string">''</span>, attachName = <span class="string">''</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> accepts = &#123;</span><br><span class="line">    <span class="string">'doc'</span>: <span class="string">'application/msword'</span>,</span><br><span class="line">    <span class="string">'xls'</span>: <span class="string">'application/vnd.ms-excel'</span>,</span><br><span class="line">    <span class="string">'xlsx'</span>: <span class="string">'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'</span></span><br><span class="line">  &#125;</span><br><span class="line">  fetch(url).then(resp =&gt; resp.arrayBuffer()).then(resp =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([resp], &#123;type: accepts[url.getExt()]&#125;)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.navigator.msSaveOrOpenBlob) &#123;</span><br><span class="line">      <span class="built_in">window</span>.navigator.msSaveOrOpenBlob(blob, attachName)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>)</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(el)</span><br><span class="line">      <span class="keyword">const</span> url = <span class="built_in">window</span>.URL.createObjectURL(blob)</span><br><span class="line">      el.href = url</span><br><span class="line">      el.download = attachName</span><br><span class="line">      el.click()</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        <span class="built_in">window</span>.URL.revokeObjectURL(url)</span><br><span class="line">        <span class="built_in">document</span>.body.removeChild(el)</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再试，还是不行，这下是android和iOS都没反应了。<br>看来需要区分android和iOS，android调用iframe，iOS另外处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">download (url = <span class="string">''</span>, attachName = <span class="string">''</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/iphone/i</span>.test(<span class="built_in">window</span>.navigator.userAgent)) &#123;</span><br><span class="line">    <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</span><br><span class="line">    iframe.style.display = <span class="string">'none'</span></span><br><span class="line">    iframe.src = url</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].appendChild(iframe)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 再试试a链接下载</span></span><br><span class="line">    <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>)</span><br><span class="line">    el.download = attachName</span><br><span class="line">    <span class="keyword">let</span> src = <span class="string">`<span class="subst">$&#123;window.location.origin&#125;</span><span class="subst">$&#123;url&#125;</span>`</span></span><br><span class="line">    el.href = src</span><br><span class="line">    el.click()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果还是iOS不行，换个文件看看，居然有些文件可以，这就有点奇怪了，调试看看：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">download (url = <span class="string">''</span>, attachName = <span class="string">''</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/iphone/i</span>.test(<span class="built_in">window</span>.navigator.userAgent)) &#123;</span><br><span class="line">    <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</span><br><span class="line">    iframe.style.display = <span class="string">'none'</span></span><br><span class="line">    iframe.src = url</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].appendChild(iframe)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(url, attachName)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一刷新，终于看出差别，有些attachName是中文，有些很长很长的名字。干脆全部处理一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">download (url = <span class="string">''</span>, attachName = <span class="string">''</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/iphone/i</span>.test(<span class="built_in">window</span>.navigator.userAgent)) &#123;</span><br><span class="line">    <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</span><br><span class="line">    iframe.style.display = <span class="string">'none'</span></span><br><span class="line">    iframe.src = url</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].appendChild(iframe)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fileName = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() + url.getExt()</span><br><span class="line">    <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>)</span><br><span class="line">    el.download = fileName</span><br><span class="line">    <span class="keyword">let</span> src = <span class="string">`<span class="subst">$&#123;window.location.origin&#125;</span><span class="subst">$&#123;url&#125;</span>`</span></span><br><span class="line">    el.href = src</span><br><span class="line">    el.click()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次为a元素的download也赋个值，iOS终于弹出下载和提示用什么app开启预览了。</p>
<h2 id="总结">总结</h2><p>因为在企业微信环境里，跟常见的浏览器不太同，根据以前做原生app的经验，猜测出错的原因有两个：</p>
<ul>
<li>iOS本身的UIWebView(也可能是WKWebView)对中文文件名编码解析出错了</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123;&#10;  // &#36825;&#37324;&#21487;&#20197;debug&#30475;&#30475;&#20250;&#19981;&#20250;throw error&#20986;&#26469;&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>企业微信对附件的拦截</li>
</ul>
<p>这种无解，老老实实使用官方提供的api:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wx.previewImage()</span><br><span class="line">wx.previewFile()</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="在企业微信网页里触发文件下载及兼容性问题">在企业微信网页里触发文件下载及兼容性问题</h2><p>在企业微信自定义网页开发文件预览功能时，官方提供了<code>wx.previewFile</code>接口可以实现。原理是<code>下载-&gt;本地预览</c]]>
    </summary>
    
      <category term="javascript" scheme="https://litt1e-p.github.io/tags/javascript/"/>
    
      <category term="vue" scheme="https://litt1e-p.github.io/tags/vue/"/>
    
      <category term="wechat app" scheme="https://litt1e-p.github.io/tags/wechat-app/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Elegant Swift -- Use @autoclosure to simplify swift syntax]]></title>
    <link href="https://litt1e-p.github.io/2018/03/07/Elegant-Swift-Use-autoclosure-to-simplify-swift-syntax/"/>
    <id>https://litt1e-p.github.io/2018/03/07/Elegant-Swift-Use-autoclosure-to-simplify-swift-syntax/</id>
    <published>2018-03-07T10:07:10.000Z</published>
    <updated>2018-03-07T13:05:43.542Z</updated>
    <content type="html"><![CDATA[<h2 id="优雅的Swift-使用@autoclosure简化语法">优雅的Swift-使用@autoclosure简化语法</h2><p>在swift中，@autoclosure属性常用于closure闭包中参数传递值时的简化表达，简而言之，可以在闭包参数传递时不用再使用花括号{}。</p>
<p>举个简单的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">foo1</span><span class="params">(<span class="number">_</span> lhs: <span class="params">()</span></span></span> -&gt; <span class="type">Int</span>, <span class="number">_</span> rhs: () -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(lhs)</span> &amp; <span class="subst">\(rhs)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">foo2</span><span class="params">(<span class="number">_</span> lhs: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">String</span>, <span class="number">_</span> rhs: <span class="preprocessor">@autoclosure</span> () -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(lhs)</span> &amp; <span class="subst">\(rhs)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若不使用<code>@autoclosure</code>属性，如foo1, 调用时：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">foo1</span><span class="params">(&#123;<span class="number">1</span>&#125;, &#123;<span class="string">"true"</span>&#125;)</span></span></span><br></pre></td></tr></table></figure>
<p>假如加入了<code>@autoclosure</code>属性，如foo2, 则：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">foo2</span><span class="params">(<span class="number">1</span>+<span class="number">2</span>, <span class="string">"true"</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>是不是简单多了？</p>
<h4 id="@autoclosure黑魔法">@autoclosure黑魔法</h4><blockquote>
<p><strong>动态类型指定</strong></p>
</blockquote>
<p>当我们不知道某些变量的类型时，如在UserDefault中、在数据库中、在Dictionary中时，通常我们会在解包取值的时候赋值一个默认值并且指定类型：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> score = (UserDefaults.standard.<span class="keyword">value</span>(forKey: <span class="string">"SomeKey"</span>) <span class="keyword">as</span>? Int) ?? <span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>这样的写法，不仅可读性非常差，而且还不太优雅。如果利用<code>@autoclosure</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UserDefaults</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">value</span><span class="generics">&lt;T&gt;</span><span class="params">(forKey key: String, defaultValue: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">T</span>) -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> value = <span class="keyword">self</span>.value(forKey: key) <span class="keyword">as</span>? <span class="type">T</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defaultValue()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">val</span> = <span class="type">UserDefaults</span>.standard.<span class="keyword">value</span>(forKey: <span class="string">"SomeKey"</span>, defaultValue: <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>结果中的val的类型则由defaultValue参数的类型决定。对比常规写法，是不是优雅多了？</p>
<h4 id="注意点">注意点</h4><p><code>@autoclosure</code>默认是<code>nonescape</code>的，如果我们需要在<code>@autoclosure</code>的基础上做进一步的说明，指明这个闭包参数是可逃逸的。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func foo<span class="function"><span class="params">(f: <span class="property">@autoclosure</span>(escaping) () -&gt; ())</span> &#123;</span><br><span class="line">    <span class="title">f</span><span class="params">()</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="参考文章">参考文章</h5><blockquote>
<p><a href="https://medium.com/@johnsundell/using-autoclosure-when-designing-swift-apis-67fe20a8b2e" target="_blank" rel="external">https://medium.com/@johnsundell/using-autoclosure-when-designing-swift-apis-67fe20a8b2e</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="优雅的Swift-使用@autoclosure简化语法">优雅的Swift-使用@autoclosure简化语法</h2><p>在swift中，@autoclosure属性常用于closure闭包中参数传递值时的简化表达，简而言之，可以在闭包参数传递时不用再使用花]]>
    </summary>
    
      <category term="elegant swift" scheme="https://litt1e-p.github.io/tags/elegant-swift/"/>
    
      <category term="swift" scheme="https://litt1e-p.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Elegant Swift -- URL]]></title>
    <link href="https://litt1e-p.github.io/2018/02/18/Elegant-Swift-URL/"/>
    <id>https://litt1e-p.github.io/2018/02/18/Elegant-Swift-URL/</id>
    <published>2018-02-18T11:29:13.000Z</published>
    <updated>2018-03-07T12:59:44.061Z</updated>
    <content type="html"><![CDATA[<h2 id="优雅的Swift_–_烦人的URL">优雅的Swift – 烦人的URL</h2><p>在日常coding中，对于URL传参，时常会误传了string类型的url，如：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="string">"https://www.github.com"</span></span><br><span class="line"><span class="keyword">let</span> task = URLSession.<span class="keyword">shared</span>.dataTask(<span class="keyword">with</span>: url)</span><br></pre></td></tr></table></figure>
<p>然后是编译器报错，然后又悻悻加上<code>URL(string: &quot;url address&quot;)</code></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let url = <span class="string">"https://www.github.com"</span></span><br><span class="line">let task = URLSession<span class="class">.shared</span><span class="class">.dataTask</span>(with: <span class="function"><span class="title">URL</span><span class="params">(string: url)</span></span>)</span><br></pre></td></tr></table></figure>
<p>有没有一种优雅的方式，让我们直接就输入String类型的网址url，自动识别转换成为URL类型的参数呢？</p>
<p>答案是有的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">URL</span>: <span class="title">ExpressibleByStringLiteral</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// By using 'StaticString' we disable string interpolation, for safety</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(stringLiteral value: <span class="type">StaticString</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span> = <span class="type">URL</span>(string: <span class="string">"<span class="subst">\(value)</span>"</span>).require(hint: <span class="string">"Invalid URL string literal: <span class="subst">\(value)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方法：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let task = URLSession<span class="class">.shared</span><span class="class">.dataTask</span>(with: <span class="string">"https://www.github.com"</span>)</span><br></pre></td></tr></table></figure>
<p>优雅一句话搞定，妈妈再也不用担心我忘记写<code>URL(string:)</code>了。</p>
<blockquote>
<p>这里的require也是一个extension方法，为了增加安全性判断</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 强制要求这个 optional 不为空</span></span><br><span class="line">    <span class="comment">/// - Parameters:</span></span><br><span class="line">    <span class="comment">/// - hint: 为空抛出的错误信息</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Returns: optional 的值.</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">require</span><span class="params">(hint hintExpression: @autoclosure<span class="params">()</span></span></span> -&gt; <span class="type">String</span>? = <span class="literal">nil</span>, file: <span class="type">StaticString</span> = #file, line: <span class="type">UInt</span> = #line) -&gt; <span class="type">Wrapped</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> unwrapped = <span class="keyword">self</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> message = <span class="string">"required value was nil <span class="subst">\(file)</span>, at line <span class="subst">\(line)</span>"</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> hint = hintExpression() &#123;</span><br><span class="line">                message.append(<span class="string">". Debugging hit: <span class="subst">\(hint)</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            #<span class="keyword">if</span> !os(<span class="type">Linux</span>)</span><br><span class="line">            <span class="keyword">let</span> exception = <span class="type">NSException</span>(name: .invalidArgumentException,</span><br><span class="line">                                        reason: message,</span><br><span class="line">                                        userInfo: <span class="literal">nil</span>)</span><br><span class="line">            exception.raise()</span><br><span class="line">            #endif</span><br><span class="line"></span><br><span class="line">            <span class="built_in">preconditionFailure</span>(message)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unwrapped</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结">总结</h4><p>这只是一个简单的思路，抛砖引玉，大家可以发散开来，为其他类型或者方法写更多更优雅的代码。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="优雅的Swift_–_烦人的URL">优雅的Swift – 烦人的URL</h2><p>在日常coding中，对于URL传参，时常会误传了string类型的url，如：</p>
<figure class="highlight vbnet"><table><tr>]]>
    </summary>
    
      <category term="elegant swift" scheme="https://litt1e-p.github.io/tags/elegant-swift/"/>
    
      <category term="swift" scheme="https://litt1e-p.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Elegant Swift -- UnWrapped or Default Value]]></title>
    <link href="https://litt1e-p.github.io/2018/02/01/Elegant-Swift-UnWrapped-or-Default-Value/"/>
    <id>https://litt1e-p.github.io/2018/02/01/Elegant-Swift-UnWrapped-or-Default-Value/</id>
    <published>2018-02-01T14:18:10.000Z</published>
    <updated>2018-03-07T12:58:52.627Z</updated>
    <content type="html"><![CDATA[<h2 id="优雅的Swift–解包">优雅的Swift–解包</h2><p>通常我们在swift中对可选值类型(optional)进行解包(unwrapped)操作时，<br>会进行一些常规的判断，如：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">String</span>?</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> _ = a &#123;</span><br><span class="line">    <span class="attribute">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再进行解包操作。那么有没有更加优雅的方式呢？</p>
<ul>
<li>利用extension进行解包</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> </span>&#123;</span><br><span class="line">@discardableResult</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">ifSome</span><span class="params">(<span class="number">_</span> closure: <span class="params">(Wrapped)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Optional</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> .some(<span class="keyword">let</span> wrapped): closure(wrapped); <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    <span class="keyword">case</span> .<span class="keyword">none</span>: <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@discardableResult</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">ifNone</span><span class="params">(<span class="number">_</span> closure: <span class="params">()</span></span></span> -&gt; ()) -&gt; <span class="type">Optional</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> .some: <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">case</span> .<span class="keyword">none</span>: closure(); <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释： <code>ifSome</code>方法利用了extension给可选值进行内部解包操作，通过传入一个closure进行是否需要解包的判断之后执行closure，<code>ifNone</code>亦同理。</p>
<p>使用方法</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let <span class="operator">a</span>: String? = <span class="string">"str"</span></span><br><span class="line"><span class="operator">a</span>.ifSome(&#123;</span><br><span class="line"><span class="comment"> //do something</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="operator">a</span>.ifNone(&#123;</span><br><span class="line"><span class="comment"> //do something</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>利用extension赋予默认值</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> `<span class="title">or</span>`<span class="params">(<span class="number">_</span> value: Wrapped)</span></span> -&gt; <span class="type">Wrapped</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span> ?? value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释：不解释了，简单。</p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a: <span class="built_in">String</span>? = nil</span><br><span class="line"><span class="keyword">let</span> v = a.or(<span class="string">"b"</span>)</span><br></pre></td></tr></table></figure>
<p>到这里有人就会问了，直接使用<code>??</code>进行解包及默认值赋值不更简单吗？</p>
<p>没错，看起来是写更少的代码看起来更简单了，实际上使用extension的这样的方法在写法上会增加可读性，因为本来的可选类型(Optional)解包时就带了个<code>?</code>, 太多<code>?</code>写在一起比语义化的<code>or</code>会降低代码的可读性。不管如何，见仁见智了。</p>
<h5 id="参考资料">参考资料</h5><blockquote>
<p><a href="https://medium.com/swift-snippets/swift-snippet-7-optional-cd9869b8b569" target="_blank" rel="external">https://medium.com/swift-snippets/swift-snippet-7-optional-cd9869b8b569</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="优雅的Swift–解包">优雅的Swift–解包</h2><p>通常我们在swift中对可选值类型(optional)进行解包(unwrapped)操作时，<br>会进行一些常规的判断，如：</p>
<figure class="highlight lasso">]]>
    </summary>
    
      <category term="elegant swift" scheme="https://litt1e-p.github.io/tags/elegant-swift/"/>
    
      <category term="swift" scheme="https://litt1e-p.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Elegant Swift -- Range]]></title>
    <link href="https://litt1e-p.github.io/2018/01/17/Elegant-Swift-Range/"/>
    <id>https://litt1e-p.github.io/2018/01/17/Elegant-Swift-Range/</id>
    <published>2018-01-17T12:56:45.000Z</published>
    <updated>2018-03-07T12:57:45.854Z</updated>
    <content type="html"><![CDATA[<h2 id="优雅的Swift–范围判断(～=操作符)">优雅的Swift–范围判断(～=操作符)</h2><p>我们对数组取值是否越界进行判断，通常的写法是：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">item</span><span class="params">(at index: Int, array: Array&lt;Element&gt;)</span></span> -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">    <span class="keyword">guard</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; array.<span class="built_in">count</span> - <span class="number">1</span> &#123; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">nil</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> array[index]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者优雅一点写成这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">item</span><span class="params">(at index: Int)</span></span> -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">guard</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="keyword">self</span>.<span class="built_in">count</span> - <span class="number">1</span> &#123; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">nil</span>&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>[index]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有没有更优雅的写法呢？看看下面这样写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">item</span><span class="params">(at index: Int)</span></span> -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">guard</span> startIndex..&lt;endIndex ~= index <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>[index]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是更加优雅点了呢？</p>
<p>操作符Operator<code>~=</code>其实是用于匹配case操作的，下面举个简单的例子：</p>
<ol>
<li>先定义一个struct</li>
</ol>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    let name: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>再implement<code>~=</code>方法</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> ~=<span class="params">(pattern: String, value: Pet)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value.name == pattern</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="type">Pet</span>(name: <span class="string">"Poly"</span>)</span><br><span class="line"><span class="keyword">switch</span> p &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"Poly"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I am Poly"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"no me"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>当调用<code>case</code>时，会调用我们自定义的<code>~=</code>方法进行判断</strong></p>
<p>或者这样判断也会调用自定义的<code>~=</code>方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> <span class="string">"Poly"</span> = p &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It's still me!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此得知Array的extension方法中的<code>startIndex..&lt;endIndex ~= index</code>同样是调用了在其内部实现的<code>~=</code>方法。</p>
<h4 id="~=_的更多示例"><code>~=</code> 的更多示例</h4><ul>
<li>1 检测变量n是否在指定范围内(10~100)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let n: Int = <span class="number">100</span></span><br><span class="line"><span class="comment">// using "patterns"</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">10.</span>.<span class="number">.100</span> ~= n&#123;</span><br><span class="line">    print(<span class="string">"inside!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2 检测http响应值</li>
</ul>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="built_in">response</span> = <span class="built_in">response</span> as? HTTPURLResponse , <span class="number">200.</span>.<span class="number">.299</span> ~= <span class="built_in">response</span>.statusCode &#123;</span><br><span class="line">    <span class="keyword">let</span> contentLength : Int64 = <span class="built_in">response</span>.expectedContentLength</span><br><span class="line">    completionHandler(contentLength)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    completionHandler(nil)</span><br></pre></td></tr></table></figure>
<h5 id="参考文章">参考文章</h5><blockquote>
<p><a href="https://stackoverflow.com/questions/38371870/operator-in-swift" target="_blank" rel="external">https://stackoverflow.com/questions/38371870/operator-in-swift</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="优雅的Swift–范围判断(～=操作符)">优雅的Swift–范围判断(～=操作符)</h2><p>我们对数组取值是否越界进行判断，通常的写法是：</p>
<figure class="highlight swift"><table><tr><td class="]]>
    </summary>
    
      <category term="elegant swift" scheme="https://litt1e-p.github.io/tags/elegant-swift/"/>
    
      <category term="swift" scheme="https://litt1e-p.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Elegant Swift -- Operator]]></title>
    <link href="https://litt1e-p.github.io/2018/01/14/Elegant-Swift-Operator/"/>
    <id>https://litt1e-p.github.io/2018/01/14/Elegant-Swift-Operator/</id>
    <published>2018-01-14T15:54:58.000Z</published>
    <updated>2018-03-07T12:56:18.457Z</updated>
    <content type="html"><![CDATA[<h2 id="优雅的Swift_–_自定义操作符(Operator)">优雅的Swift – 自定义操作符(Operator)</h2><p>自从有了extension后，swift写出的代码变得优雅了许多。我们常会看到一些开源的第三方库会出现一些诡异的符号。比如著名的json解析库<a href="https://github.com/hkellaway/Gloss" target="_blank" rel="external">gloss</a>中的<code>~~&gt;</code>、<code>&lt;~~</code>，还有<a href="https://github.com/thoughtbot/Argo" target="_blank" rel="external">Argo</a>中的<code>&lt;^&gt;</code>、<code>&lt;*&gt;</code>、<code>&lt;|</code>、<code>&lt;|?</code>、<code>&lt;||</code>等等。</p>
<p>这种叫做操作符(Operator)的东西实际上比extension更加地优雅，因为不用再写个方法名来调用，简单一个符号即可神奇地达到调用的目的。</p>
<p>下面我们来自定义一个操作符，来实现简单base64加密的功能。</p>
<h5 id="基本概念">基本概念</h5><p>1.运算符定义</p>
<ul>
<li>prefix 表示定义一个前位操作符（前是输入）</li>
<li>infix 表示定义一个中位操作符（前后都是输入）</li>
<li>postfix 表示定义一个后位操作符（后是输入）</li>
</ul>
<p>2.结合律 associativity (计算顺序)</p>
<ul>
<li>left （从左往右的顺序）</li>
<li>right（从右往左的顺序）</li>
<li>none（默认就为 none，不会再结合）</li>
</ul>
<p>3.优先级 Precedence</p>
<ul>
<li>higherThan 优先级高于</li>
<li>lowerThan 优先级低于</li>
</ul>
<p>常用的Precedence，详见<a href="https://developer.apple.com/documentation/swift/operator_declarations" target="_blank" rel="external">官方文档</a></p>
<p>我们也可以自定义一个Precedence。</p>
<h5 id="实战">实战</h5><p>简单用一个自定义操作符，实现base64加密和解密功能。</p>
<ol>
<li><p>先定义一个优先级group</p>
 <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">precedencegroup</span> <span class="tag">MyPrecedence</span> &#123;</span><br><span class="line"> <span class="attribute">associativity</span>: none</span><br><span class="line"> <span class="attribute">higherThan</span>: AdditionPrecedence</span><br><span class="line"> <span class="attribute">lowerThan</span>: MultiplicationPrecedence</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这里associativity因为没有前后输入顺序就直接使用默认的none，Precedence我们比加法(AdditionPrecedence)高，比乘法(MultiplicationPrecedence)低就行了，因为如果是数字遇到运算需要进行优先级的判断。</p>
</li>
<li><p>定义一个操作符</p>
 <figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="infix"><span class="keyword">infix</span> operator *=* : MyPrecedence</span></span><br></pre></td></tr></table></figure>
<p> 这里定义一个中位操作符</p>
</li>
<li><p>实现功能的方法</p>
 <figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> enum CryptoType &#123;</span><br><span class="line">    <span class="keyword">case</span> encrypt, decrypt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func *=* (input: <span class="built_in">String</span>, <span class="keyword">type</span>: CryptoType) <span class="subst">-&gt; </span><span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">type</span> == <span class="built_in">.</span>encrypt &#123;</span><br><span class="line">        guard <span class="keyword">let</span> utf8Data = input<span class="built_in">.</span><span class="built_in">data</span>(using: <span class="built_in">String</span><span class="built_in">.</span>Encoding<span class="built_in">.</span>utf8) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">String</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> utf8Data<span class="built_in">.</span>base64EncodedString()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        guard <span class="keyword">let</span> utf8Data = <span class="built_in">Data</span>(base64Encoded: input) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">String</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">String</span>(<span class="built_in">data</span>: utf8Data, encoding: <span class="built_in">.</span>utf8) ?? <span class="built_in">String</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这里声明一个枚举，动态切换加密或者解密操作。</p>
</li>
<li><p>测试</p>
 <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let <span class="operator">a</span> = <span class="string">"1234567890"</span> *=* .<span class="built_in">encrypt</span></span><br><span class="line">print(<span class="operator">a</span>)<span class="comment"> // MTIzNDU2Nzg5MA==</span></span><br><span class="line">let b = <span class="operator">a</span> *=* .<span class="built_in">decrypt</span></span><br><span class="line">print(b)<span class="comment"> // 1234567890</span></span><br></pre></td></tr></table></figure>
<p> 大功告成。撒花🎉🎉🎉</p>
</li>
</ol>
<h5 id="总结">总结</h5><p>使用自定义操作符，可以大大提高代码优(zhuang)雅(bi)性，相对于extension更加简洁明了。但是要注意，自定义操作符的作用域是全局的，可能会存在一些风险，慎重使用。</p>
<h5 id="参考资料">参考资料</h5><blockquote>
<p><a href="https://developer.apple.com/documentation/swift/operator_declarations#topic-content" target="_blank" rel="external">https://developer.apple.com/documentation/swift/operator_declarations#topic-content</a></p>
<p><a href="https://stackoverflow.com/questions/45134496/understanding-precedence-groups-assignment-in-swift-3-1" target="_blank" rel="external">https://stackoverflow.com/questions/45134496/understanding-precedence-groups-assignment-in-swift-3-1</a>;</p>
<p><a href="https://github.com/NSCookies/articles/blob/master/publish/%E8%A3%85%E4%B8%AA%E9%80%BC%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6.md" target="_blank" rel="external">https://github.com/NSCookies/articles/blob/master/publish/%E8%A3%85%E4%B8%AA%E9%80%BC%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6.md</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="优雅的Swift_–_自定义操作符(Operator)">优雅的Swift – 自定义操作符(Operator)</h2><p>自从有了extension后，swift写出的代码变得优雅了许多。我们常会看到一些开源的第三方库会出现一些诡异的符号。比如著名的json]]>
    </summary>
    
      <category term="Operator" scheme="https://litt1e-p.github.io/tags/Operator/"/>
    
      <category term="elegant swift" scheme="https://litt1e-p.github.io/tags/elegant-swift/"/>
    
      <category term="swift" scheme="https://litt1e-p.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Elegant Swift -- Generic typealias in closure]]></title>
    <link href="https://litt1e-p.github.io/2018/01/09/Elegant-Swift-Generic-typealias-in-closure/"/>
    <id>https://litt1e-p.github.io/2018/01/09/Elegant-Swift-Generic-typealias-in-closure/</id>
    <published>2018-01-09T12:33:39.000Z</published>
    <updated>2018-03-07T12:34:40.869Z</updated>
    <content type="html"><![CDATA[<h2 id="优雅的Swift_–_闭包中的范型">优雅的Swift – 闭包中的范型</h2><p>从swift 3开始有了范型(Generic type), 范型除了常用在方法里作参数的声明之外，其实还可以使用于闭包(Closure)回调中，据此可以使用任何类型在closure中。</p>
<h4 id="示例">示例</h4><p>我们可以先定义一个简单的closure:</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typealias Closure&lt;T&gt; = <span class="function"><span class="params">(T)</span> -&gt;</span> Void</span><br><span class="line"><span class="regexp">//</span>返回值为空</span><br></pre></td></tr></table></figure>
<p>使用方法：</p>
<ul>
<li>1 使用Bool类型</li>
</ul>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> boolClosure: Closure&lt;<span class="built_in">Bool</span>&gt; = &#123; boolValue <span class="keyword">in</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">boolClosure(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>2 使用String类型</li>
</ul>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> strClosure: Closure&lt;<span class="built_in">String</span>&gt; = &#123; strValue <span class="keyword">in</span></span><br><span class="line">    <span class="attribute">...</span></span><br><span class="line">&#125;</span><br><span class="line">strClosure(<span class="string">"I am string"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>3 其他类型同理</li>
</ul>
<h4 id="更多Closure示例">更多Closure示例</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typealias Closure&lt;T, U&gt; = <span class="function"><span class="params">(T)</span> -&gt;</span> (U)</span><br><span class="line"></span><br><span class="line">typealias Closure&lt;T&gt; = <span class="function"><span class="params">(T)</span> -&gt;</span> Void</span><br><span class="line"></span><br><span class="line">typealias Closure&lt;T&gt; = <span class="function"><span class="params">()</span> -&gt;</span> T</span><br><span class="line"></span><br><span class="line">typealias Closure = <span class="function"><span class="params">()</span> -&gt;</span> Void</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="优雅的Swift_–_闭包中的范型">优雅的Swift – 闭包中的范型</h2><p>从swift 3开始有了范型(Generic type), 范型除了常用在方法里作参数的声明之外，其实还可以使用于闭包(Closure)回调中，据此可以使用任何类型在closu]]>
    </summary>
    
      <category term="Generic type" scheme="https://litt1e-p.github.io/tags/Generic-type/"/>
    
      <category term="elegant swift" scheme="https://litt1e-p.github.io/tags/elegant-swift/"/>
    
      <category term="swift" scheme="https://litt1e-p.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Use ES7 async&await in Wechat app]]></title>
    <link href="https://litt1e-p.github.io/2018/01/07/Use-ES7-async-await-in-Wechat-app/"/>
    <id>https://litt1e-p.github.io/2018/01/07/Use-ES7-async-await-in-Wechat-app/</id>
    <published>2018-01-07T11:06:45.000Z</published>
    <updated>2018-03-07T12:25:54.256Z</updated>
    <content type="html"><![CDATA[<h2 id="在微信小程序中使用_ES7_async&amp;await">在微信小程序中使用 ES7 async&amp;await</h2><p>微信小程序虽然已经支持Promiss，在一定程度上缓解了臭名昭著的callback hell：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(&#123;data: <span class="string">"Hello,World"</span>&#125;)</span><br><span class="line">        &#125;, <span class="number">5000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是仍不够解耦不够优雅，若是支持ES7的async和await就好了，可惜微信MINA IDE还不支持这个特性，只能自己动手实现了。</p>
<h4 id="原理">原理</h4><p>首先，async/await也是和Promise配合使用的。具体语法不一一赘述，详见<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="external">ES7 Async Await</a></p>
<p>这里举个简单的使用例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wxLogin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        wx.login(&#123;</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (r.code) &#123;</span><br><span class="line">                    resolve(r)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    reject(<span class="string">'获取用户登录状态失败！'</span> + r.errMsg)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            fail: <span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                reject(<span class="string">'获取用户登录状态失败'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">tryLogin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> rs = <span class="keyword">await</span> wxLogin().catch(e =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.info(e)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">"logined!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tryLogin()</span><br></pre></td></tr></table></figure>
<p>是不是优雅多了。跟callback hell say byebye.</p>
<h4 id="配置">配置</h4><p>那么又该如何实现呢？微信MINA自带了Babel转换工具，但不够强大，这里我们自己来配置一个Babel来转换编译我们的代码。</p>
<p>所以，我们先把MINA里的<code>开启ES6转ES5</code>关闭，我们用自己的Babel。</p>
<p><img src="http://ww4.sinaimg.cn/large/006tKfTcgy1fp32ylaplyj311c0ak75l.jpg" alt=""></p>
<p>然后用Gulp来写我的脚本，从Gulp中调用Babel来编译我的代码。z在调用Babel时，需要给我们的Babel配置插件以支持async/await，比如async-to-generator，async-generator-functions等插件。</p>
<ol>
<li><p>Babel的配置</p>
<p> 编辑Babel的配置文件：.babelrc，这里直接用<code>latest</code>，便支持ES7。</p>
 <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//.<span class="atom">babelrc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"presets"</span>: [ <span class="string">"latest"</span> ],  </span><br><span class="line">  <span class="string">"plugins"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Glup的配置</p>
<p> 把我们小程序项目下所有的js文件都通过Babel编译：</p>
 <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">gulp.<span class="keyword">task</span>(<span class="string">'scripts'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src([<span class="string">'./src/**/*.js'</span>])</span><br><span class="line">        .pipe(babel())</span><br><span class="line">        .pipe(gulpAddRequireRuntime())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./dist'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function gulpAddRequireRuntime() &#123;</span><br><span class="line">    <span class="keyword">return</span> through.obj(function(<span class="keyword">file</span>, enc, cb) &#123;</span><br><span class="line">        var prefixText = ``;</span><br><span class="line">        var rel = path.relative(path.dirname(<span class="keyword">file</span>.path), path.<span class="keyword">join</span>(<span class="keyword">file</span>.base, <span class="string">'lib/runtime.js'</span>));</span><br><span class="line">        rel = rel.replace(<span class="regexp">/\\/g</span>, <span class="string">'/'</span>);</span><br><span class="line">        <span class="keyword">if</span> (rel === <span class="string">'runtime.js'</span>) &#123;</span><br><span class="line">            prefixText = <span class="keyword">new</span> Buffer(prefixText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prefixText = `var regeneratorRuntime = require(<span class="string">"$&#123;rel&#125;"</span>);`;</span><br><span class="line">            prefixText = <span class="keyword">new</span> Buffer(prefixText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">file</span>.isNull()) &#123;</span><br><span class="line">            cb(<span class="keyword">null</span>, <span class="keyword">file</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">file</span>.isBuffer()) &#123;</span><br><span class="line">            <span class="keyword">file</span>.contents = Buffer.concat([prefixText, <span class="keyword">file</span>.contents]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">file</span>.isStream()) &#123;</span><br><span class="line">            <span class="keyword">file</span>.contents = <span class="keyword">file</span>.contents.pipe(prefixStream(prefixText));</span><br><span class="line">        &#125;</span><br><span class="line">        cb(<span class="keyword">null</span>, <span class="keyword">file</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="使用">使用</h4><ol>
<li>项目目录结构</li>
</ol>
<p><img src="http://ww2.sinaimg.cn/large/006tKfTcgy1fp3384dryfj30mu0e675n.jpg" alt=""></p>
<p>如图，这里dist目录正是Gulp编译输出目录，在微信MINA中直接用这个目录即可，而src目录则为我们愉快编写ES7的async&amp;await的目录啦。</p>
<ol>
<li>依赖库</li>
</ol>
<p>经过Babel转译后的代码是通过类似co库的方式来实现的，即需要使用到generator，所以，和我们使用co的时候一样，需要依赖一个regeneratorRuntime，才能支持generator特性。我们这使用Facebook开源的<a href="https://github.com/facebook/regenerator/" target="_blank" rel="external">regenerator</a>。</p>
<p>安装regenerator</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> regenerator</span></span><br></pre></td></tr></table></figure>
<ol>
<li>引入</li>
</ol>
<p>把刚才npm安装的regenerator下的<code>rumtime.js</code>复制到我们的src/lib下，然后在需要使用的地方引入即可愉快又优雅地写我们的async/await代码啦。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const RUNTIME = <span class="function"><span class="title">require</span><span class="params">(<span class="string">"/lib/runtime"</span>)</span></span></span><br></pre></td></tr></table></figure>
<h5 id="参考资料">参考资料</h5><blockquote>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function</a><br><a href="https://www.jianshu.com/p/270f129e5af3" target="_blank" rel="external">https://www.jianshu.com/p/270f129e5af3</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="在微信小程序中使用_ES7_async&amp;await">在微信小程序中使用 ES7 async&amp;await</h2><p>微信小程序虽然已经支持Promiss，在一定程度上缓解了臭名昭著的callback hell：</p>
<figure clas]]>
    </summary>
    
      <category term="javascript" scheme="https://litt1e-p.github.io/tags/javascript/"/>
    
      <category term="wechat app" scheme="https://litt1e-p.github.io/tags/wechat-app/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Build a notification center for wechat app]]></title>
    <link href="https://litt1e-p.github.io/2017/12/30/Build-a-notification-center-for-wechat-app/"/>
    <id>https://litt1e-p.github.io/2017/12/30/Build-a-notification-center-for-wechat-app/</id>
    <published>2017-12-30T02:30:15.000Z</published>
    <updated>2018-03-07T12:31:37.676Z</updated>
    <content type="html"><![CDATA[<h2 id="为微信小程序建立通知中心">为微信小程序建立通知中心</h2><p>微信小程序目前为止，页面传值的方式主要有：</p>
<ul>
<li>globalData 全局共享变量</li>
<li>wx.navigateTo等页面之间跳转的url传值，在目标页<code>onLoad</code>中获取</li>
<li>wx.setStorage缓存变量</li>
<li>其他？(欢迎补充)</li>
</ul>
<p>做过app，特别是iOS app的同学肯定知道原生app除了上述的方式还有众多的传值甚至反向传值方式，如block，delegate传值，kvo等，其中最少不了的是一对多的<code>NotificationCenter/NSNotificationCenter</code>，做WeChat app时怎么可以没有通知中心呢，GitHub上也有一位<br>国内的程序员写一个类似通知中心的js库叫<a href="https://github.com/binnng/broadcast.js" target="_blank" rel="external">broadcast.js</a>，原理也是大致相同，从注册通知到通知中心发送通知、收到通知，源码比较简单，只有30行左右，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> WIN, broadcast;</span><br><span class="line"></span><br><span class="line">WIN = <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">broadcast = &#123;</span><br><span class="line">  on: <span class="function"><span class="keyword">function</span>(<span class="params">name, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> eventData;</span><br><span class="line">    eventData = broadcast.data;</span><br><span class="line">    <span class="keyword">if</span> (eventData.hasOwnProperty(name)) &#123;</span><br><span class="line">      eventData[name].push(fn);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      eventData[name] = [fn];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  fire: <span class="function"><span class="keyword">function</span>(<span class="params">name, data, thisArg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fn, fnList, i, len;</span><br><span class="line">    thisArg = thisArg || WIN;</span><br><span class="line">    fnList = broadcast.data[name];</span><br><span class="line">    <span class="keyword">if</span> (!fnList.length) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Cannot find broadcast event "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, len = fnList.length; i &lt; len; i++) &#123;</span><br><span class="line">      fn = fnList[i];</span><br><span class="line">      fn.apply(thisArg, [data, name]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  data: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> exports !== <span class="string">"undefined"</span> &amp;&amp; <span class="built_in">module</span>.exports) &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = broadcast;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  WIN.broadcast = broadcast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大体上思路是正确的，但存在bug，在判断待通知的事件数组fnList时，源码直接判断<code>if (!fnList.length)</code>就throw error，在实际使用中会crash，因为可能找不到对应事件的名字，也就是说发送通知时如果发送一个未注册的通知的话，fnList都还是null或者undefined的。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在调用发送通知前，必须先注册该通知</span></span><br><span class="line">broadcast.reg(config.kAppTestNotificationKey, <span class="function"><span class="keyword">function</span> <span class="params">(cb)</span> </span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>这其实相当尴尬，我决定把它修改一下，顺便把方法名也一起修改一下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> WIN, notificationCenter;</span><br><span class="line">WIN = <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">notificationCenter = &#123;</span><br><span class="line">    addObserver: <span class="function"><span class="keyword">function</span>(<span class="params">name, fn</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> eventData;</span><br><span class="line">        eventData = notificationCenter.data;</span><br><span class="line">        <span class="keyword">if</span> (eventData.hasOwnProperty(name)) &#123;</span><br><span class="line">            eventData[name].push(fn);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            eventData[name] = [fn];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    post: <span class="function"><span class="keyword">function</span>(<span class="params">name, data, thisArg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fn, fnList, i, len;</span><br><span class="line">        thisArg = thisArg || WIN;</span><br><span class="line">        fnList = notificationCenter.data[name];</span><br><span class="line">        <span class="keyword">if</span> (!fnList || !fnList.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Cannot find notificationCenter event "</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, len = fnList.length; i &lt; len; i++) &#123;</span><br><span class="line">            fn = fnList[i];</span><br><span class="line">            fn.apply(thisArg, [data, name]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    data: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> exports !== <span class="string">"undefined"</span> &amp;&amp; <span class="built_in">module</span>.exports) &#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = notificationCenter;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    WIN.notificationCenter = notificationCenter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在发送一个未注册的通知时也不会throw error了，可是，这代码仍然还有bug：这个notificationCenter自身的事件对象<code>data</code>中储存着所有事件，其实数据结构为：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"noti1"</span>: [<span class="literal">k1</span>, <span class="literal">k2</span>, ...],</span><br><span class="line">    <span class="string">"noti2"</span>: [<span class="literal">k1</span>, <span class="literal">k2</span>, ...],</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并没有提供removeObserver移除事件通知的方法，其造成对象内部数组的无限增加，在每一次发送通知时遍历时间会无限增加，时间复杂度O(n)会随着通知对象及其内部事件数组数量增加而增加。为此应该再修改一下，增加一个移除事件通知的方法：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">removeObserver: <span class="function"><span class="keyword">function</span><span class="params">(name, fn)</span> &#123;</span></span><br><span class="line">    var eventData, fnList, <span class="built_in">i</span>, len;</span><br><span class="line">    eventData = notificationCenter.data;</span><br><span class="line">    fnList = notificationCenter.data<span class="matrix">[name]</span>;</span><br><span class="line">    <span class="keyword">if</span> (!fnList || !fnList.<span class="built_in">length</span>) <span class="cell">&#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">i</span> = <span class="number">0</span>, len = fnList.<span class="built_in">length</span>; <span class="built_in">i</span> &lt; len; <span class="built_in">i</span>++) <span class="cell">&#123;</span><br><span class="line">        if (fnList[i] == fn) &#123;</span><br><span class="line">            fnList.splice(i, <span class="number">1</span>)</span><br><span class="line">        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> this;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>现在好了，有<code>addObserver</code>、<code>post</code>、<code>removeObserver</code>方法了，大体上满足了我们的使用要求，是否已经完美了呢？</p>
<p>答案是否定的，为什么呢？不妨想想看，这个通知中心库，在每一个需要使用的page里都需要进行一次引入操作：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> notificationCenter = <span class="function"><span class="title">require</span><span class="params">(<span class="string">"./lib/notificationCenter"</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>有些人就会疑虑了：这每require一次，是不是都new了一次这个notificationCenter？如果是的话，意味着这个notificationCenter并不是一个单例，然后不同地方require生成不同的对象，甚至还有线程争夺的问题……</p>
<p>事实真的如此吗？其实在node.js官方文档中，说明了require是引入一个单例</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Every call <span class="built_in">to</span> <span class="built_in">require</span>(<span class="string">'foo'</span>) will <span class="built_in">get</span> exactly <span class="operator">the</span> same object returned, <span class="keyword">if</span> <span class="keyword">it</span> would <span class="built_in">resolve</span> <span class="built_in">to</span> <span class="operator">the</span> same <span class="built_in">file</span>.</span><br></pre></td></tr></table></figure>
<p>举个<a href="https://medium.com/@lazlojuly/are-node-js-modules-singletons-764ae97519af" target="_blank" rel="external">medium</a>例子：</p>
<p>定义一个类</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> counter.js</span><br><span class="line"></span><br><span class="line">let value = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attribute">increment</span>: <span class="function"><span class="params">()</span> =&gt;</span> value++,</span><br><span class="line">  <span class="attribute">get</span>: <span class="function"><span class="params">()</span> =&gt;</span> value,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再require测试：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app-singleton.js</span></span><br><span class="line"></span><br><span class="line">const counter1 = <span class="function"><span class="title">require</span><span class="params">(‘./counter.js’)</span></span></span><br><span class="line">const counter2 = <span class="function"><span class="title">require</span><span class="params">(‘./counter.js’)</span></span></span><br><span class="line"></span><br><span class="line">counter1.<span class="function"><span class="title">increment</span><span class="params">()</span></span></span><br><span class="line">counter1.<span class="function"><span class="title">increment</span><span class="params">()</span></span></span><br><span class="line">counter2.<span class="function"><span class="title">increment</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">console.<span class="function"><span class="title">log</span><span class="params">(counter1.get()</span></span>) <span class="comment">// prints 3</span></span><br><span class="line">console.<span class="function"><span class="title">log</span><span class="params">(counter2.get()</span></span>) <span class="comment">// also prints 3</span></span><br></pre></td></tr></table></figure>
<p>证明了require是单次引入，本质上跟单例一致。所以不用担心这个notificationCenter非全局单例的疑虑。至此，这个通知中心也差不多完成了。</p>
<h5 id="参考资料">参考资料</h5><blockquote>
<p><a href="http://imweb.io/topic/582293894067ce9726778be9" target="_blank" rel="external">http://imweb.io/topic/582293894067ce9726778be9</a><br><a href="https://github.com/binnng/broadcast.js/blob/master/broadcast.js" target="_blank" rel="external">https://github.com/binnng/broadcast.js/blob/master/broadcast.js</a><br><a href="https://medium.com/@lazlojuly/are-node-js-modules-singletons-764ae97519af" target="_blank" rel="external">https://medium.com/@lazlojuly/are-node-js-modules-singletons-764ae97519af</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="为微信小程序建立通知中心">为微信小程序建立通知中心</h2><p>微信小程序目前为止，页面传值的方式主要有：</p>
<ul>
<li>globalData 全局共享变量</li>
<li>wx.navigateTo等页面之间跳转的url传值，在目标页<code]]>
    </summary>
    
      <category term="javascript" scheme="https://litt1e-p.github.io/tags/javascript/"/>
    
      <category term="notification" scheme="https://litt1e-p.github.io/tags/notification/"/>
    
      <category term="wechat app" scheme="https://litt1e-p.github.io/tags/wechat-app/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Use git hooks to deploy automatically]]></title>
    <link href="https://litt1e-p.github.io/2017/09/07/Use%20git%20hooks%20to%20deploy%20automatically/"/>
    <id>https://litt1e-p.github.io/2017/09/07/Use git hooks to deploy automatically/</id>
    <published>2017-09-07T14:55:47.000Z</published>
    <updated>2018-03-07T12:51:47.411Z</updated>
    <content type="html"><![CDATA[<h4 id="git_hooks_实现自动部署">git hooks 实现自动部署</h4><p>当我们在本地执行push命令到git服务器的时候，服务器会自动触发post-receive钩子。</p>
<p>假如有一个git服务器仓库目录 例如: /home/git/test.git<br>和一个web服务器目录，例如: /home/wwwroot/default/testRoot</p>
<p>先在web目录里clone一份仓库<br>cd /home/wwwroot/default/testRoot<br>git clone /home/git/test.git</p>
<p>然后使用服务端git钩子 post-receive，它位于/home/git/test.git/hooks<br>cd /home/git/test.git/hooks/<br>这里有post-receive.sample<br>cp post-receive.sample post-receive<br>vi post-receive<br>写入如下代码:</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unset GIT_DIR </span><br><span class="line">echo <span class="string">'copying to web deploy directory...'</span></span><br><span class="line">CurrentPath=`pwd`</span><br><span class="line">echo <span class="variable">$CurrentPath</span></span><br><span class="line">DeployPath=<span class="string">"/home/wwwroot/default/testRoot"</span></span><br><span class="line">cd <span class="variable">$DeployPath</span> || exit</span><br><span class="line">git pull origin master</span><br><span class="line">echo <span class="string">"update will be completed soon"</span></span><br><span class="line">cd <span class="variable">$CurrentPath</span></span><br><span class="line">exit <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><code>如果不加 unset GIT_DIR #还原环境变量 就会报出 remote: fatal: not git respository:’.’ 错误</code><br>保存后赋予可执行权限<br>chmod +x /home/git/test.git/hooks/post-receive</p>
<p>修改web服务器根目录的权限<br>因为执行拉取的时候是git用户所以要把web服务器根目录(/home/wwwroot/default/testRoot) 的权限设定为git用户</p>
<p>chown -R git:git /home/wwwroot/default/testRoot</p>
<p>参考网址：<br><a href="http://www.jianshu.com/p/f9312b51e011" target="_blank" rel="external">git hooks 实现自动部署</a><br><a href="http://robin-front.github.io/2016/08/11/%E7%94%A8Git-Hooks%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2-%E8%AE%A9%E6%8F%90%E4%BA%A4%E5%8F%91%E5%B8%83%E8%87%AA%E5%8A%A8%E5%8C%96/" target="_blank" rel="external">用Git-Hooks进行自动部署,让提交发布自动化</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="git_hooks_实现自动部署">git hooks 实现自动部署</h4><p>当我们在本地执行push命令到git服务器的时候，服务器会自动触发post-receive钩子。</p>
<p>假如有一个git服务器仓库目录 例如: /home/git/test]]>
    </summary>
    
      <category term="git" scheme="https://litt1e-p.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Build a git repo server]]></title>
    <link href="https://litt1e-p.github.io/2017/08/25/Build-a-git-repo-server/"/>
    <id>https://litt1e-p.github.io/2017/08/25/Build-a-git-repo-server/</id>
    <published>2017-08-25T13:12:54.000Z</published>
    <updated>2018-03-07T12:14:18.729Z</updated>
    <content type="html"><![CDATA[<h4 id="步骤">步骤</h4><p>yum install git</p>
<p>groupadd git<br>adduser git -g git<br>passwd git //设置密码</p>
<p>// git用户的～目录: /home/git</p>
<p>mkdir /home/git/.ssh &amp;&amp; touch /home/git/.ssh/authorized_keys<br>chmod 700 /home/git/.ssh<br>chmod 600 /home/git/.ssh/authorized_keys</p>
<p>//把本地电脑的.ssh/id_rsa.pub里的内容复制并粘贴到远程的/home/git/.ssh/authorized_keys, 若有多个则一行一个</p>
<p>//初始化一个叫做test的仓库<br>cd /home/git &amp; git init –bare test.git</p>
<p>chown -R git:git test.git</p>
<p>//禁用shell登录<br>//1.先找到git-shell的路径<br>grep git-shell /etc/shells || su -c “echo <code>which git-shell</code> &gt;&gt; /etc/shells”<br>eg.控制台输出：/usr/bin/git-shell<br>//2.修改git用户的shell登录<br>vi /etc/passwd<br>//找到类似下面的一行：<br>git:x:1001:1001:,,,:/home/git:/bin/bash<br>//改成<br>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell<br>//这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出<br>//测试：<br>ssh git@your-server-name-or-ip<br>//输入密码后显示如下信息即成功<br>fatal: What do you think I am? A shell?<br>Connection to <code>your-server-name-or-ip</code> closed.<br>//给git用户增加push权限<br>usermod -s /bin/bash git</p>
<p>//在本地电脑中clone仓库<br>git clone git@your-server-name-or-ip:test.git</p>
<p>//ps. 这里若服务器改了默认的ssh 22端口, 可以在本地电脑中(~/.ssh/)新建config文件<br>vi ~/.ssh/config<br>//config内容：<br>host your-server-name-or-ip<br>hostname  your-server-name-or-ip<br>port your-server-port</p>
<p>假设windows上已经有个本地仓库，并且与别名叫origin的远程仓库进行了关联，那么，我们只需要将origin所指向的远程仓库的链接改为我们刚搭建的git服务器：<br>git remote set-url origin git@your-server-name-or-ip:my-project.git<br>如果是本地还没有仓库，可以执行下面的命令，并将其与远程仓库进行关联：<br>git init &amp;&amp; git remote add origin git@your-server-name-or-ip:my-project.git</p>
<p>参考网址：<br><a href="https://git-scm.com/book/zh/v1/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E6%9E%B6%E8%AE%BE%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="external">服务器上的 Git - 架设服务器</a><br><a href="http://www.dabu.info/vps-set-private-git-server.html" target="_blank" rel="external">用vps搭建私有的git服务器</a><br><a href="http://www.pubyun.com/blog/deveops/%E6%9C%AC%E5%9C%B0ssh%E9%9D%9E%E6%A0%87%E5%87%86%E7%AB%AF%E5%8F%A3%E6%97%B6%EF%BC%8C%E8%BF%9E%E6%8E%A5github-com/" target="_blank" rel="external">本地ssh非标准端口时，连接github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="步骤">步骤</h4><p>yum install git</p>
<p>groupadd git<br>adduser git -g git<br>passwd git //设置密码</p>
<p>// git用户的～目录: /home/git</p>
<p>m]]>
    </summary>
    
      <category term="git" scheme="https://litt1e-p.github.io/tags/git/"/>
    
      <category term="git server" scheme="https://litt1e-p.github.io/tags/git-server/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Lock in iOS]]></title>
    <link href="https://litt1e-p.github.io/2017/06/17/Lock-in-iOS/"/>
    <id>https://litt1e-p.github.io/2017/06/17/Lock-in-iOS/</id>
    <published>2017-06-17T02:05:08.000Z</published>
    <updated>2018-03-07T12:06:21.094Z</updated>
    <content type="html"><![CDATA[<h2 id="iOS锁">iOS锁</h2><h4 id="死锁">死锁</h4><p>一个示例<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)run &#123;</span><br><span class="line">    <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"1"</span>);</span></span><br><span class="line">    <span class="comment">//主队列的同步线程，按照FIFO的原则（先入先出），2排在3后面会等3执行完，但因为同步线程，3又要等2执行完，相互等待成为死锁。</span></span><br><span class="line">    <span class="function">dispatch_sync</span>(<span class="function">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">        <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"2"</span>);</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"3"</span>);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出1之后发生死锁，sync到当前主线程(串行队列)的block将会引起死锁。原因是dispatch_sync将一个block插入到main queue中，sync会等待到这个block执行完成后才返回继续执行(async则不会等待)，而这个block的执行还等待着run中dispatch_sync调用的结束，所以造成了循环等待，导致死锁。</p>
<h4 id="互斥锁POSIX">互斥锁POSIX</h4><p>POSIX和<code>dispatch_semaphore_t</code>很像，但是完全不同。POSIX是Unix/Linux平台上提供的一套条件互斥锁的API。<br>为了锁住和解锁一个互斥锁，你可以使用<code>pthread_mutex_lock</code>和<code>pthread_mutex_unlock</code>函数。当你用完一个锁之后，只要简单的调用<code>pthread_mutex_destroy</code>来释放该锁的数据结构。<br>互斥锁提供了三个函数，从函数名就可以知道他们的作用：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(pthread_mutex_t *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(pthread_mutex_t *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(pthread_mutex_t *mutex)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>函数<code>pthread_mutex_trylock</code>和<code>pthread_mutex_lock</code>的功能相似，只不过前者在获取锁失败的情况下会立即返回，而后者则会一直阻塞在那里直到获取到锁为止<br>。</p>
<p>举例<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">POSIXViewController</span> () </span>&#123;</span><br><span class="line">    pthread_mutex_t mutex;  <span class="comment">//声明pthread_mutex_t的结构</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">POSIXViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);  <span class="comment">//释放该锁的数据结构</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  初始化</span><br><span class="line">     *</span><br><span class="line">     */</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)getImageName:(<span class="built_in">NSMutableArray</span> *)imageNames &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *imageName;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  加锁</span><br><span class="line">     */</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span> (imageNames<span class="variable">.count</span>&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        imageName = [imageNames firstObject];</span><br><span class="line">        [imageNames removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  解锁</span><br><span class="line">     */</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>POSIX还可以创建条件锁，提供了和NSCondition一样的条件控制，初始化互斥锁同时使用pthread_cond_init来初始化条件数据结构，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span> <span class="params">(pthread_cond_t *cond, pthread_condattr_t *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待（会阻塞）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span> <span class="params">(pthread_cond_t *cond, pthread_mutex_t *mut)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span> <span class="params">(pthread_cond_t *cond, pthread_mutex_t *mut, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *abstime)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span> <span class="params">(pthread_cond_t *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span> <span class="params">(pthread_cond_t *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span> <span class="params">(pthread_cond_t *cond)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="互斥锁NSLock">互斥锁NSLock</h4><p>NSLock中实现了一个简单的互斥锁。所有锁（包括NSLock）的接口实际上都是通过NSLocking协议定义的，它定义了lock和unlock方法。你使用这些方法来获取和释放该锁。NSLock类使用的是POSIX线程来实现它的锁操作。</p>
<p>NSLock不能被用来实现迭代锁，因为如果发生lock消息两次的话，整个线程将被永久锁住。</p>
<p>除了标准的锁行为，NSLock类还增加了tryLock和lockBeforeDate:方法。方法tryLock试图获取一个锁，但是如果锁不可用的时候，它不会阻塞线程。相反，它只是返回NO。而lockBeforeDate:方法试图获取一个锁，但是如果锁没有在规定的时间内被获得，它会让线程从阻塞状态变为非阻塞状态（或者返回NO）。</p>
<p>NSLock的执行原理：<br>某个线程A调用lock方法。这样，NSLock将被上锁。可以执行“关键部分”，完成后，调用unlock方法。如果，在线程A 调用unlock方法之前，另一个线程B调用了同一锁对象的lock方法。那么，线程B只有等待。直到线程A调用了unlock。</p>
<p>使用时，基本方法就是：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSLock *<span class="keyword">lock</span> = [[NSLock alloc] init];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">lock</span> <span class="keyword">lock</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">lock</span> unlock];</span><br></pre></td></tr></table></figure></p>
<p>此外，还可以为NSLock设置name：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)newName</span><br><span class="line">- (<span class="built_in">NSString</span> *)name <span class="comment">//返回锁指定的Name</span></span><br></pre></td></tr></table></figure></p>
<h4 id="指令@synchronized">指令@synchronized</h4><p>@synchronized是在Objective-C中最简单方法，只要有个Objective-C对象就可以完成线程同步操作。@synchronized指令做和其他互斥锁一样的工作（它防止不同的线程在同一时间获取同一个锁）。你不需要直接创建一个互斥锁或锁对象。相反，你只需要简单的使用Objective-C对象作为锁的令牌。需要注意的是，@synchronized会隐式地添加异常处理代码，也就是当发生异常时会自动释放互斥锁，所以会有一定的性能损耗。</p>
<p>示例：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)<span class="function"><span class="keyword">method</span>:</span>(id)anObj <span class="comment">&#123;</span><br><span class="line">    @synchronized(anObj) &#123;</span><br><span class="line">        // Everything between the braces is protected by the @synchronized directive.</span><br><span class="line">    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//swift 写法</span></span><br><span class="line">objc_sync_enter(<span class="keyword">self</span>)</span><br><span class="line"><span class="comment">//需要执行的代码块</span></span><br><span class="line">objc_sync_exit(<span class="keyword">self</span>)</span><br></pre></td></tr></table></figure></p>
<p>传给@synchronized指令的对象是用来区别保护块的唯一标示，如果你在两个不同的线程里面执行上述方法，每次在一个线程传递了一个不同的对象给anObj参数，那么每次都将会拥有它的锁，并持续处理，中间不被其他线程阻塞。然而，如果你传递的是<code>同一个对象</code>，那么多个线程中的一个线程会首先获得该锁，而其他线程将会被阻塞直到第一个线程完成。</p>
<p>作为一种预防措施，@synchronized块隐式的添加一个异常处理例程来保护代码。该处理例程会在异常抛出的时候自动的释放互斥锁。这意味着为了使用@synchronized指令，你必须在你的代码中启用异常处理。如果你不想让隐式的异常处理例程带来额外的开销，你应该考虑使用锁的类。</p>
<h4 id="GCD信号量锁_dispatch_semaphore_t和dispatch_semaphore_wait">GCD信号量锁 dispatch_semaphore_t和dispatch_semaphore_wait</h4><p>dispatch_semaphore 信号量基于计数器的一种多线程同步机制。dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); 如果semaphore计数大于等于1.计数－1，程序继续运行。如果计数为0，则等待。这里设置的等待时间是一直等待。dispatch_semaphore_signal(semaphore);计数＋1.在这两句代码中间的执行代码，每次只会允许一个线程进入，这样就有效的保证了在多线程环境下，只能有一个线程进入。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">//获取全局并发队列</span></span><br><span class="line"><span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">1</span>); <span class="comment">//创建信号量</span></span><br><span class="line">NSMutableArray *<span class="built_in">array</span> = [NSMutableArrayarray];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">100000</span>; index++) &#123;</span><br><span class="line">    dispatch_async(<span class="built_in">queue</span>, ^()&#123; <span class="comment">//并发队列里执行任务</span></span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); <span class="comment">// semaphore计数大于等于1.计数－1，程序继续运行。如果计数为0，则等待</span></span><br><span class="line">        NSLog(@<span class="string">"addd :%d"</span>, index);</span><br><span class="line">        [<span class="built_in">array</span> addObject:[NSNumber numberWithInt:index]];</span><br><span class="line">        dispatch_semaphore_signal(semaphore); <span class="comment">//计数＋1</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="递归锁_NSRecursiveLock">递归锁 NSRecursiveLock</h4><p>NSRecursiveLock这个锁可以被同一线程多次请求，而不会引起死锁。NSRecursiveLock通常被用在一个递归函数里面来防止递归造成阻塞线程，只有当多次获取的锁全部释放时，NSRecursiveLock才能被其他线程获取。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NSLock *<span class="keyword">lock</span> = [[NSLock alloc] init];</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">void</span> (<span class="params">^RecursiveMethod</span>)(<span class="params"><span class="keyword">int</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">    RecursiveMethod = ^(<span class="keyword">int</span> <span class="keyword">value</span>) &#123;</span><br><span class="line">        [<span class="keyword">lock</span> <span class="keyword">lock</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            NSLog(<span class="string">@"value = %d"</span>, <span class="keyword">value</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            RecursiveMethod(<span class="keyword">value</span> - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">lock</span> unlock];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    RecursiveMethod(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码是一个典型的死锁情况。在我们的线程中，RecursiveMethod是递归调用的。所以每次进入这个block时，都会去加一次锁，而从第二次开始，由于锁已经被使用了且没有解锁，所以它需要等待锁被解除，这样就导致了死锁，线程被阻塞住了。</p>
<p>在这种情况下，我们就可以使用NSRecursiveLock，只需要把<code>NSLock *lock = [[NSLock alloc] init];</code>改成<code>NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];</code>即可。</p>
<p>与NSLock一样，拥有<code>tryLock</code>和<code>lockBeforeDate:</code>及<code>setName</code>等方法</p>
<h4 id="条件锁_NSConditionLock">条件锁 NSConditionLock</h4><p>也有人说这是个互斥锁<br>NSConditionLock同样实现了NSLocking协议，试验过程中发现性能很低</p>
<p>示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个并发队列</span></span><br><span class="line">synchronizationQueue = dispatch_queue_create([@<span class="string">"com.mac.synchronization"</span> cStringUsingEncoding:NSASCIIStringEncoding], DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)remove:(NSMutableArray *)data &#123;</span><br><span class="line">    NSString *str;</span><br><span class="line">    [lock lockWhenCondition:<span class="number">1</span>];    <span class="comment">//条件加锁</span></span><br><span class="line">    <span class="keyword">if</span> (data.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        str = [data lastObject];</span><br><span class="line">        [data removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    [lock unlockWithCondition:<span class="number">0</span>];     <span class="comment">//改变条件解锁</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)add:(NSMutableArray *)data &#123;</span><br><span class="line">    [lock lockWhenCondition:<span class="number">0</span>]; <span class="comment">//条件加锁</span></span><br><span class="line">    [data addObject:@<span class="string">"0"</span>];</span><br><span class="line">    [lock unlockWithCondition:<span class="number">1</span>]; <span class="comment">//改变条件解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> mark - 多线程取出数据后删除</span></span><br><span class="line">- (<span class="keyword">void</span>)getDataInMultiThread &#123;</span><br><span class="line">    NSMutableArray *data = [NSMutableArray <span class="built_in">array</span>];</span><br><span class="line">    <span class="keyword">dispatch_group_t</span> dispatchGroup = dispatch_group_create();</span><br><span class="line">    __block <span class="keyword">double</span> then, now;</span><br><span class="line">    then = CFAbsoluteTimeGetCurrent();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">        dispatch_group_async(dispatchGroup, synchronizationQueue, ^()&#123;</span><br><span class="line">            [self remove:data];</span><br><span class="line">        &#125;);</span><br><span class="line">        dispatch_group_async(dispatchGroup, synchronizationQueue, ^()&#123;</span><br><span class="line">            [self add:data];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_group_notify(dispatchGroup, synchronizationQueue, ^()&#123;</span><br><span class="line">        now = CFAbsoluteTimeGetCurrent();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread_lock: %f sec\n data count: %ld\n"</span>, now-then, data.count);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>条件锁的初始状态是<code>&quot;0&quot;</code>，所以<code>add</code>线程在这个时候就会获取到锁，执行完成后再把状态设置为<code>&quot;1&quot;</code>；这时<code>remove</code>线程发现条件变成<code>&quot;1&quot;</code>后就可以获取到锁，直到执行结束后再把状态设置成<code>&quot;0&quot;</code>。</p>
<h4 id="条件锁与互斥锁结合体_NSCondition">条件锁与互斥锁结合体 NSCondition</h4><p>NSCondition类是互斥锁和条件锁的结合体，也就是一个线程在等待信号而阻塞时，可以被另外一个线程唤醒<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">NSCondition </span>*<span class="keyword">cond</span> = [[<span class="constant">NSCondition </span>alloc] init];</span><br><span class="line">[<span class="keyword">cond</span> lock];</span><br><span class="line"><span class="keyword">while</span> (timeToDoWork &lt;= <span class="number">0</span>)</span><br><span class="line">[<span class="keyword">cond</span> wait];</span><br><span class="line">timeToDoWork--;</span><br><span class="line"><span class="regexp">//</span> <span class="constant">Do </span>real work here.</span><br><span class="line">[<span class="keyword">cond</span> unlock];</span><br></pre></td></tr></table></figure></p>
<p>在其他线程中唤醒：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">[<span class="keyword"><span class="built_in">cond</span></span> lock]<span class="comment">;</span></span><br><span class="line">timeToDoWork++<span class="comment">;</span></span><br><span class="line"><span class="list">[<span class="keyword"><span class="built_in">cond</span></span> signal]<span class="comment">;</span></span><br><span class="line"><span class="list">[<span class="keyword"><span class="built_in">cond</span></span> unlock]<span class="comment">;</span></span></span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="互斥锁、跨进程的分布式锁_NSDistributedLock">互斥锁、跨进程的分布式锁 NSDistributedLock</h4><p>NSDistributedLock是MAC开发中的跨进程的分布式锁，底层是用文件系统实现的互斥锁。NSDistributedLock没有实现NSLocking协议，所以没有lock方法，取而代之的是非阻塞的tryLock方法。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSDistributedLock *<span class="keyword">lock</span> = [[NSDistributedLock alloc] initWithPath:<span class="string">@"/Users/mac/Desktop/lock.lock"</span>];</span><br><span class="line"><span class="keyword">while</span> (![<span class="keyword">lock</span> tryLock]) &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">[<span class="keyword">lock</span> unlock];</span><br></pre></td></tr></table></figure></p>
<p>NSDistributedLock只有在锁持有者显式地释放后才会被释放，也就是说当持有锁的应用崩溃后，其他应用就不能访问受保护的共享资源了。<br>如当执行到do something时程序退出,程序再次启动之后tryLock就再也不能成功了,陷入死锁状态.其他应用也不能访问受保护的共享资源。在这种情况下，你可以使用breadLock方法来打破现存的锁以便你可以获取它。但是通常应该避免打破锁，除非你确定拥有进程已经死亡并不可能再释放该锁。</p>
<h4 id="自旋锁OSSpinLock">自旋锁OSSpinLock</h4><p>首先要提的是OSSpinLock已经出现了BUG，导致并不能完全保证是线程安全的。</p>
<blockquote>
<p>新版 iOS 中，系统维护了 5 个不同的线程优先级/QoS: background，utility，default，user-initiated，user-interactive。高优先级线程始终会在低优先级线程前执行，一个线程不会受到比它更低优先级线程的干扰。这种线程调度算法会产生潜在的优先级反转问题，从而破坏了 spin lock。<br>具体来说，如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。这并不只是理论上的问题，libobjc 已经遇到了很多次这个问题了，于是苹果的工程师停用了 OSSpinLock。<br>苹果工程师 Greg Parker 提到，对于这个问题，一种解决方案是用 truly unbounded backoff 算法，这能避免 livelock 问题，但如果系统负载高时，它仍有可能将高优先级的线程阻塞数十秒之久；另一种方案是使用 handoff lock 算法，这也是 libobjc 目前正在使用的。锁的持有者会把线程 ID 保存到锁内部，锁的等待者会临时贡献出它的优先级来避免优先级反转的问题。理论上这种模式会在比较复杂的多锁条件下产生问题，但实践上目前还一切都好。<br>OSSpinLock 自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。对于内存缓存的存取来说，它非常合适。<br>-摘自<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="external">ibireme-不再安全的 OSSpinLock</a></p>
</blockquote>
<p>示例：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#import &lt;libkern/OSAtomic.h&gt;</span></span><br><span class="line"><span class="comment">@interface OSSpinLockViewController () &#123;</span></span><br><span class="line">    OSSpinLock spinlock;  //声明pthread_mutex_t的结构</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">@implementation OSSpinLockViewController</span></span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    /<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">     <span class="keyword">*</span>  初始化</span><br><span class="line">     <span class="keyword">*</span></span><br><span class="line">     <span class="keyword">*</span>/</span><br><span class="line">    spinlock = OS_SPINLOCK_INIT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)run &#123;</span><br><span class="line">    /<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">     <span class="keyword">*</span>  加锁</span><br><span class="line">     <span class="keyword">*</span>/</span><br><span class="line">    OSSpinLockLock(&amp;spinlock);</span><br><span class="line">    //do something</span><br><span class="line">    /<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">     <span class="keyword">*</span>  解锁</span><br><span class="line">     <span class="keyword">*</span>/</span><br><span class="line">    OSSpinLockUnlock(&amp;spinlock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">@end</span></span><br></pre></td></tr></table></figure></p>
<p>iOS 10 之后，苹果给出了解决方案，就是用 os_unfair_lock 代替 OSSpinLock</p>
<p><code>&#39;OSSpinLockLock&#39; is deprecated: first deprecated in iOS 10.0 - Use os_unfair_lock_lock() from &lt;os/lock.h&gt; instead</code></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;os/lock.h&gt;</span><br><span class="line"></span><br><span class="line">__block os_unfair_lock lock = OS_UNFAIR_LOCK_INIT<span class="comment">;</span></span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">   os_unfair_lock_lock(&amp;lock)<span class="comment">;</span></span><br><span class="line">   NSLog(@"第一个线程同步操作开始")<span class="comment">;</span></span><br><span class="line">   sleep(8)<span class="comment">;</span></span><br><span class="line">   NSLog(@"第一个线程同步操作结束")<span class="comment">;</span></span><br><span class="line">   os_unfair_lock_unlock(&amp;lock)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">   sleep(1)<span class="comment">;</span></span><br><span class="line">   os_unfair_lock_lock(&amp;lock)<span class="comment">;</span></span><br><span class="line">   NSLog(@"第二个线程同步操作开始")<span class="comment">;</span></span><br><span class="line">   os_unfair_lock_unlock(&amp;lock)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">//执行结果</span><br><span class="line">//<span class="number">2017-11-30</span> <span class="number">15:12:31.70</span><span class="number">1180+0800</span> 第一个线程同步操作开始</span><br><span class="line">//<span class="number">2017-11-30</span> <span class="number">15:12:39.70</span><span class="number">5473+0800</span> 第一个线程同步操作结束</span><br><span class="line">//<span class="number">2017-11-30</span> <span class="number">15:12:39.70</span><span class="number">5820+0800</span> 第二个线程同步操作开始</span><br></pre></td></tr></table></figure>
<p>自旋锁和互斥锁异同</p>
<p>相同点：都能保证同一时间只有一个线程访问共享资源。都能保证线程安全。</p>
<p>不同点：</p>
<p>互斥锁：如果共享数据已经有其他线程加锁了，线程会进入休眠状态等待锁。一旦被访问的资源被解锁，则等待资源的线程会被唤醒。</p>
<p>自旋锁：如果共享数据已经有其他线程加锁了，线程会以死循环的方式等待锁，一旦被访问的资源被解锁，则等待资源的线程会立即执行。</p>
<p>自旋锁的效率高于互斥锁。</p>
<h4 id="GCD线程阻断dispatch_barrier_async/dispatch_barrier_sync">GCD线程阻断dispatch_barrier_async/dispatch_barrier_sync</h4><p>dispatch_barrier_async/dispatch_barrier_sync在一定的基础上也可以做线程同步，会在线程队列中打断其他线程执行当前任务，也就是说<code>只有用在并发的线程队列中</code>才会有效，因为串行队列本来就是一个一个的执行的，你打断执行一个和插入一个是一样的效果。两个的区别是是否等待任务执行完成。</p>
<blockquote>
<p>注意：如果在当前线程调用dispatch_barrier_sync打断会发生死锁。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">__block <span class="keyword">double</span> then, now;</span><br><span class="line"><span class="comment">//创建一个并发队列</span></span><br><span class="line">synchronizationQueue = dispatch_queue_create([@<span class="string">"com.mac.synchronization"</span> cStringUsingEncoding:NSASCIIStringEncoding], DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)getData:(NSMutableArray *)data &#123;</span><br><span class="line">    NSString *str;</span><br><span class="line">    <span class="keyword">if</span> (data.count&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        str = [data firstObject];</span><br><span class="line">        [data removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        now = CFAbsoluteTimeGetCurrent();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread_lock: %f sec\n data count: %ld\n"</span>, now-then, data.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)getDataWithMultiThread &#123;</span><br><span class="line">    NSMutableArray *data = [NSMutableArray <span class="keyword">new</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1024</span>*<span class="number">11</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">        [data addObject:[NSString stringWithFormat:@<span class="string">"%d"</span>, i]];</span><br><span class="line">    &#125;</span><br><span class="line">    then = CFAbsoluteTimeGetCurrent();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//100来测试锁有没有正确的执行</span></span><br><span class="line">        dispatch_barrier_async(synchronizationQueue, ^&#123;</span><br><span class="line">             [self getData:data];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="各种锁性能">各种锁性能</h4><p><img src="https://user-gold-cdn.xitu.io/2017/12/8/1603542bc602d97f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h4 id="总结">总结</h4><ul>
<li><code>POSIX</code>(pthread_mutex)：底层的api，复杂的多线程处理建议使用，并且可以封装自己的多线程</li>
<li><code>@synchronized</code>：适用线程不多，任务量不大的多线程加锁</li>
<li><code>NSLock</code>：其实NSLock并没有想象中的那么差，不知道大家为什么不推荐使用</li>
<li><code>dispatch_semaphore_t</code>：使用信号来做加锁，性能提升显著</li>
<li><code>NSCondition</code>：使用其做多线程之间的通信调用不是线程安全的</li>
<li><code>NSConditionLock</code>：单纯加锁性能非常低，比NSLock低很多，但是可以用来做多线程处理不同任务的通信调用</li>
<li><code>NSRecursiveLock</code>：递归锁的性能出奇的高，但是只能作为递归使用,所以限制了使用场景</li>
<li><code>NSDistributedLock</code>：因为是MAC开发的，就不讨论了</li>
<li><code>OSSpinLock</code>：性能也非常高，可惜出现了线程不安全问题，使用 os_unfair_lock 来代替</li>
<li><code>dispatch_barrier_async/dispatch_barrier_sync</code>：测试中发现dispatch_barrier_sync比dispatch_barrier_async性能要高</li>
</ul>
<h6 id="参考资料">参考资料</h6><blockquote>
<p><a href="https://www.jianshu.com/p/35dd92bcfe8c" target="_blank" rel="external">https://www.jianshu.com/p/35dd92bcfe8c</a><br><a href="http://www.bijishequ.com/detail/354750" target="_blank" rel="external">http://www.bijishequ.com/detail/354750</a><br><a href="https://github.com/YasinZhou/ThreadLockDemo" target="_blank" rel="external">https://github.com/YasinZhou/ThreadLockDemo</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="iOS锁">iOS锁</h2><h4 id="死锁">死锁</h4><p>一个示例<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1<]]>
    </summary>
    
      <category term="Lock" scheme="https://litt1e-p.github.io/tags/Lock/"/>
    
      <category term="Objective-C" scheme="https://litt1e-p.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Runloop]]></title>
    <link href="https://litt1e-p.github.io/2017/05/07/Runloop/"/>
    <id>https://litt1e-p.github.io/2017/05/07/Runloop/</id>
    <published>2017-05-07T12:01:37.000Z</published>
    <updated>2018-03-07T12:02:48.148Z</updated>
    <content type="html"><![CDATA[<h5 id="什么是RunLoop？">什么是RunLoop？</h5><p>从字面意义看：运行循环，其实它内部就是do-while循环，在这个循环内部不断地处理各种任务（比如Source、Timer、Observer）<br>一个线程对应一个RunLoop，主线程的RunLoop默认已经启动，子线程的RunLoop得手动启动（调用run方法）<br>RunLoop只能选择一个Mode启动，如果当前Mode中没有任何Source(Sources0、Sources1)、Timer，那么就直接退出RunLoop</p>
<h4 id="基本作用">基本作用</h4><p>保持程序的运行循环<br>处理app中的各种时间（比如触摸事件、定时器事件、selector事件）<br>节省CPU资源，提高程序性能：该做事时做事，该休息时休息</p>
<h4 id="RunLoop对象">RunLoop对象</h4><p>iOS中有2套API来访问和使用RunLoop</p>
<ul>
<li>Foundation</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>NSRunLoop</span><br></pre></td></tr></table></figure>
<ul>
<li>Core Foundation</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>CFRunLoopRef</span><br></pre></td></tr></table></figure>
<p>NSRunLoop和CFRunLoopRef都代表着RunLoop对象<br>NSRunLoop是基于CFRunLoopRef的一层OC包装，所以要了解RunLoop内部结构，需要多研究CFRunLoopRef层面的API（Core Foundation层面）</p>
<h4 id="RunLoop与线程间关系">RunLoop与线程间关系</h4><p>每条线程都有唯一的一个与之对应的RunLoop对象<br>主线程的RunLoop已经自动创建好了，子线程的RunLoop需要主动创建<br>RunLoop在第一次获取时创建，在线程结束时销毁</p>
<h4 id="获得RunLoop对象的方法">获得RunLoop对象的方法</h4><ul>
<li>Foundation</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[NSRunLoop currentRunLoop]</span>;  <span class="comment">//获得当前线程的RunLoop对象</span></span><br><span class="line"><span class="attr_selector">[NSRunLoop mainRunLoop]</span>;  <span class="comment">//获得主线程的RunLoop对象</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Core Foundation</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopGetCurrent</span>();  <span class="comment">//获得当前线程的RunLoop对象</span></span><br><span class="line"><span class="built_in">CFRunLoopGetMain</span>();  <span class="comment">//获得主线程的RunLoop对象</span></span><br></pre></td></tr></table></figure>
<h4 id="RunLoop的结构组成">RunLoop的结构组成</h4><p>Core Foundation中关于RunLoop的5个类<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopRef</span>          <span class="comment">// RunLoop对象自身</span></span><br><span class="line"><span class="built_in">CFRunLoopModeRef</span>      <span class="comment">// RunLoop的运行模式</span></span><br><span class="line"><span class="built_in">CFRunLoopSourceRef</span>    <span class="comment">// 数据源、事件源</span></span><br><span class="line"><span class="built_in">CFRunLoopTimerRef</span>     <span class="comment">// NSTimer</span></span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span>  <span class="comment">// 观察、监听RunLoop</span></span><br></pre></td></tr></table></figure></p>
<p>在RunLoop中有多个运行模式，但是RunLoop只能选择一种模式运行<br>mode里面至少要有一个timer或者source，observer可有可无（只是用来观察／监听RunLoop）</p>
<h4 id="RunLoop的运行模式Mode">RunLoop的运行模式Mode</h4><p>一个RunLoop包含若干个Mode，每个Mode又包含若干个Source/Timer/Observer<br>每次RunLoop启动时，只能指定其中一个Mode，这个Mode被称作CurrentMode<br>这样做主要是为了分隔开不同组的Source/Timer/Observer，让其互不影响</p>
<p>系统默认注册了5个Mode</p>
<ul>
<li>kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行（常用）</li>
<li>UITrackingRunLoopMode: 界面追踪Mode，用于tableView、ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响（常用）</li>
<li>UIInitializationRunLoopMode：在刚启动App时，进入的第一个mode，启动后就不再使用</li>
<li>GSEventReceiveRunLoopMode：接受系统事件的内部Mode，通常用不到</li>
<li>kCFRunLoopCommonModes：这是一个占位用的Mode，不是真正的Mode</li>
</ul>
<h4 id="主线程中(main函数)的runLoop">主线程中(main函数)的runLoop</h4><p>1.Objective-C中<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>UIApplicationMain函数内部就启动了一个RunLoop<br>所以UIApplication函数一直没有返回，保持了程序的持续运行<br>这个默认启动的RunLoop是跟主线程相关联的</p>
<p>2.Swift中<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@UIApplicationMain</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="typename">UIResponder</span>, <span class="typename">UIApplicationDelegate &#123;&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>Swift在AppDelegate.swift中用标签<code>@UIApplicationMain</code>来取代了main函数，也可以自行创建main.swift来当做程序的入口，这时候要将标签@UIApplicationMain注释，main.swift代码如下<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIApplicationMain<span class="list">(<span class="keyword">CommandLine</span>.argc, UnsafeMutableRawPointer<span class="list">(<span class="keyword">CommandLine</span>.unsafeArgv)</span>.bindMemory<span class="list">(<span class="keyword">to</span>: UnsafeMutablePointer&lt;Int8&gt;.self, capacity: Int<span class="list">(<span class="keyword">CommandLine</span>.argc)</span>)</span>, <span class="literal">nil</span>, NSStringFromClass<span class="list">(<span class="keyword">AppDelegate</span>.self)</span>)</span></span><br></pre></td></tr></table></figure></p>
<h4 id="子线程中的runloop">子线程中的runloop</h4><p>eg.timer: 需要手动创建runloop并附加到当前子线程运行</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(timer) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)timer &#123;</span><br><span class="line">    <span class="comment">// 如果是在子线程中使用此timer创建方式，则需要手动创建runLoop</span></span><br><span class="line">    <span class="built_in">NSRunLoop</span> *currentRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该方法内部自动添加到runLoop中，并且设置运行模式为默认</span></span><br><span class="line">    [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子线程中创建runLoop之后不会执行，需要手动开启runLoop</span></span><br><span class="line">    [currentRunLoop run];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若在主线程的runloop创建timer：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSTimer *timer = [NSTimer <span class="string">timerWithTimeInterval:</span><span class="number">2.0</span> <span class="string">target:</span>self <span class="string">selector:</span><span class="annotation">@selector</span>(run) <span class="string">userInfo:</span>nil <span class="string">repeats:</span>YES];</span><br><span class="line"></span><br><span class="line">[[NSRunLoop currentRunLoop] <span class="string">addTimer:</span>timer <span class="string">forMode:</span>NSDefaultRunLoopMode];<span class="comment">//默认模式</span></span><br><span class="line">[[NSRunLoop currentRunLoop] <span class="string">addTimer:</span>timer <span class="string">forMode:</span>UITrackingRunLoopMode];<span class="comment">//页面追踪模式</span></span><br><span class="line">[[NSRunLoop currentRunLoop] <span class="string">addTimer:</span>timer <span class="string">forMode:</span>NSRunLoopCommonModes]; <span class="comment">//common模式</span></span><br></pre></td></tr></table></figure></p>
<p><code>*注意：NSRunLoopCommonModes = NSDefaultRunLoopMode + UITrackingRunLoopMode</code></p>
<h4 id="在开发中如何使用RunLoop？什么应用场景？">在开发中如何使用RunLoop？什么应用场景？</h4><ul>
<li>开启一个常驻线程（让一个子线程不进入消亡状态，等待其他线程发来消息，处理其他事件）</li>
<li>在子线程中开启一个定时器</li>
<li>在子线程中进行一些长期监控</li>
<li>可以控制定时器在特定模式下执行</li>
<li>可以让某些事件（行为、任务）在特定模式下执行</li>
<li>可以添加Observer监听RunLoop的状态，比如监听点击事件的处理（在所有点击事件之前做一些事情）</li>
</ul>
<h4 id="自动释放池什么时候创建？什么时候释放？">自动释放池什么时候创建？什么时候释放？</h4><ul>
<li>第一次创建在：启动runLoop的时候</li>
<li>最后一次销毁在：runLoop退出的时候</li>
<li>其他时候的创建和销毁：当runLoop即将睡眠的时候销毁之前的释放池，并重新创建一个新的</li>
</ul>
<hr>
<h6 id="参考资料">参考资料</h6><blockquote>
<p><a href="http://www.bijishequ.com/detail/228372" target="_blank" rel="external">http://www.bijishequ.com/detail/228372</a><br><a href="http://www.bijishequ.com/detail/234634" target="_blank" rel="external">http://www.bijishequ.com/detail/234634</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h5 id="什么是RunLoop？">什么是RunLoop？</h5><p>从字面意义看：运行循环，其实它内部就是do-while循环，在这个循环内部不断地处理各种任务（比如Source、Timer、Observer）<br>一个线程对应一个RunLoop，主线程的RunLo]]>
    </summary>
    
      <category term="Objective-C" scheme="https://litt1e-p.github.io/tags/Objective-C/"/>
    
      <category term="Runloop" scheme="https://litt1e-p.github.io/tags/Runloop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Runtime]]></title>
    <link href="https://litt1e-p.github.io/2017/03/06/Runtime/"/>
    <id>https://litt1e-p.github.io/2017/03/06/Runtime/</id>
    <published>2017-03-06T12:32:31.000Z</published>
    <updated>2018-04-09T03:56:54.903Z</updated>
    <content type="html"><![CDATA[<h4 id="简介">简介</h4><p>Objective-C 是一门动态语言，它的动态性体现在它将很多编译和链接时做的事推延到运行时处理，而这一机制主要依赖系统提供的 runtime 库。利用 runtime 库，我们能在运行时做很多事，例如 objc_setAssociatedObject 动态绑定属性、method swizzling、class_copyIvarList 动态获取属性实现 ORM（Object Relational Mapping）、消息转发等。</p>
<h4 id="消息转发">消息转发</h4><p>Objective-C 中的方法调用最终都是执行消息发送，如</p>
<p><code>[receiver message]</code></p>
<p>最后会转换成</p>
<p><code>objc_msgSend(receiver, selector)</code></p>
<p>如果 receiver 不响应 message 消息，则会去父类查找，父类还不响应继续去父类查找，如果一直查找到 NSObject 还不响应，则会进入消息动态处理流程。</p>
<h4 id="消息动态处理">消息动态处理</h4><p>如果一个类不响应某个具体的方法，在进入消息转发流程前还有两个时机处理，第一是询问是否有动态添加方法来进行处理（<code>resolveInstanceMethod/resolveClassMethod</code>）, 若没有则询问有没有别人能够帮忙处理一下啊，调用的是<code>forwardingTargetForSelector</code>这个方法。</p>
<ul>
<li>resolveInstanceMethod / resolveClassMethod</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="tag">BOOL</span>)<span class="tag">resolveInstanceMethod</span><span class="pseudo">:(SEL)sel</span>;</span><br><span class="line">+ (<span class="tag">BOOL</span>)<span class="tag">resolveClassMethod</span><span class="pseudo">:(SEL)sel</span>;</span><br></pre></td></tr></table></figure>
<p>在这个方法中我们可以利用runtime的特性动态添加方法来处理，具体如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A.m</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"sel is %@"</span>, <span class="built_in">NSStringFromSelector</span>(sel));</span><br><span class="line">    <span class="keyword">if</span>(sel == <span class="keyword">@selector</span>(setName:))&#123;</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> class], sel, (IMP)a,<span class="string">"v@:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态处理方法</span></span><br><span class="line"><span class="keyword">void</span> a(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// implementation ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中class_addMethod的四个参数分别是：</p>
<ol>
<li>Class cls 给哪个类添加方法，本例中是self</li>
<li>SEL name 添加的方法，本例中是重写的拦截调用传进来的selector。</li>
<li>IMP imp 方法的实现，C方法的方法实现可以直接获得。如果是OC方法，可以用+ (IMP)instanceMethodForSelector:(SEL)aSelector;获得方法的实现。</li>
<li>“<code>v@:*</code>“方法的签名，代表有一个参数的方法。</li>
</ol>
<ul>
<li>forwardingTargetForSelector</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A.m</span></span><br><span class="line">- (id)<span class="string">forwardingTargetForSelector:</span>(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果代理对象能处理，则转接给代理对象</span></span><br><span class="line">    B *b = [[B alloc] init];</span><br><span class="line">    <span class="keyword">if</span> ([b <span class="string">respondsToSelector:</span>aSelector]) &#123;</span><br><span class="line">        <span class="keyword">return</span> proxyObj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不能处理进入转发流程</span></span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B.m</span></span><br><span class="line">- (<span class="typename">void</span>)b&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>也找不到能够帮忙处理这条未知消息，那就会走到最后一步</p>
<ul>
<li>forwardInvocation &amp; methodSignatureForSelector</li>
</ul>
<p>调用<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>，在调用forwardInvocation:之前会调用<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>方法来获取这个选择子的方法签名，然后在<code>-(void)forwardInvocation:(NSInvocation *)anInvocation</code>方法中你就可以通过anInvocation拿到相应信息做处理，实例代码如下</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当A类 收到一条`c`的消息的时候，前两步发现都没办法处理掉，走到第三步：</span></span><br><span class="line"><span class="comment">//A.m</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"forwardInvocation: %@"</span>, <span class="built_in">NSStringFromSelector</span>([anInvocation selector]));</span><br><span class="line">    <span class="keyword">if</span> ([anInvocation selector] == <span class="keyword">@selector</span>(c)) &#123;</span><br><span class="line">        C *c = [[C alloc] init];</span><br><span class="line">        [anInvocation invokeWithTarget:c];</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"method signature for selector: %@"</span>, <span class="built_in">NSStringFromSelector</span>(aSelector));</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(c)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">"V@:@"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C.m</span></span><br><span class="line">- (<span class="keyword">void</span>)c&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>消息转发流程如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/8/8/a65b266e187329db430c8120aab53ffc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>那么最后消息未能处理的时候，还会调用到<br><code>- (void)doesNotRecognizeSelector:(SEL)aSelector</code>这个方法，我们也可以在这个方法中做些文章，避免掉crash，但是只建议在线上环境的时候做处理，实际开发过程中还要把异常抛出来</p>
<h4 id="isa、Class_和_MetaClass">isa、Class 和 MetaClass</h4><p>Objective-C 是 C 的超集，提供了面向对象的机制，而面向对象思想里有两个重要的概念：类和实例</p>
<p>在 runtime.h 中我们可以看到如下定义：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_<span class="built_in">AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#if !__OBJC2__</span></span><br><span class="line">    Class super_class                                        OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="comment">/* Use `Class` instead of `struct objc_class *` */</span></span><br></pre></td></tr></table></figure></p>
<p>isa：是一个Class 类型的指针. 每个实例对象有个isa的指针, 它<code>指向对象的类</code>，而Class里也有个isa的指针, 指向metaClass(元类)。<br>元类也有isa指针,它的isa指针最终指向的是一个根元类(root metaClass).根元类的isa指针指向本身，这样形成了一个封闭的内循环。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//B.h</span></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">B</span>: NSObject</span><br><span class="line"></span><br><span class="line">+ (void)classFuncB;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//A.h</span></span><br><span class="line">#import <span class="string">"B.h"</span></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">A</span>: B</span><br><span class="line"></span><br><span class="line">+ (void)classFuncA;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line">#import <span class="string">"A.m"</span></span><br><span class="line"></span><br><span class="line">A *a = [[A alloc] init];</span><br><span class="line"><span class="comment">//此时a的isa指向类A(Class A)</span></span><br><span class="line"><span class="comment">//类A的isa指向类A的metaClass，类A的metaClass储存着类方法`classFuncA`</span></span><br><span class="line"></span><br><span class="line"><span class="attr_selector">[A classFuncB]</span>;</span><br><span class="line"><span class="comment">//此时类A调用类方法`classFuncB`, 但类A的metaClass找不到`classFuncB`, 则会去A的父类B的metaClass里找到`classFuncB`，</span></span><br></pre></td></tr></table></figure>
<p>继承关系：</p>
<ol>
<li>类继承（Class）：<code>A--&gt;B--&gt;NSObject--&gt;nil</code></li>
<li>元类继承 （MetaClass）：<code>MetaA--&gt;MetaB--&gt;RootMeta--&gt;NSObject(Class)--&gt;nil</code></li>
<li>isa继承：<code>实例a的isa--&gt;类A的isa--&gt;元类A的isa--&gt;RootMeta(根元类)的isa--&gt;RootMeta(根元类)自身的isa</code>, 类B同理。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/449095-3e972ec16703c54d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240/q/100" alt=""></p>
<ul>
<li><p>每一个对象本质上都是一个类的实例。其中类定义了成员变量和成员方法的列表。对象通过对象的isa指针指向类。</p>
</li>
<li><p>每一个类本质上都是一个对象，类其实是元类（metaClass）的实例。元类定义了类方法的列表。类通过类的isa指针指向元类。</p>
</li>
<li><p>所有的元类最终继承一个根元类，根元类isa指针指向本身，形成一个封闭的内循环。</p>
</li>
</ul>
<p>元类保存了<code>类方法</code>的列表。当类方法被调用时，先会从本身查找类方法的实现，如果没有，元类会向他父类查找该方法。</p>
<h4 id="load与initialize">load与initialize</h4><table>
<thead>
<tr>
<th></th>
<th>+ load</th>
<th>+ initialize</th>
</tr>
</thead>
<tbody>
<tr>
<td>调用时机</td>
<td>被添加到 runtime 时, 通常就是App启动时进行加载</td>
<td>收到第一条消息前(主动使用该类时)，可能永远不调用</td>
</tr>
<tr>
<td>调用顺序</td>
<td>父类-&gt;子类-&gt;分类</td>
<td>父类-&gt;子类</td>
</tr>
<tr>
<td>调用次数</td>
<td>1次</td>
<td>多次</td>
</tr>
<tr>
<td>是否需要显式调用父类实现</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>是否沿用父类的实现</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>分类中的实现</td>
<td>类和分类都执行</td>
<td>覆盖类中的方法，只执行分类的实现</td>
</tr>
<tr>
<td>常见应用</td>
<td>runtime method swizzling</td>
<td>可用来做一些初始化工作，如单例模式。</td>
</tr>
</tbody>
</table>
<h4 id="method_swizzling">method swizzling</h4><p>注意点：</p>
<ul>
<li>需要在<code>+(void)load</code>方法里</li>
<li>使用<code>dispatch_once</code>只交换一次</li>
</ul>
<p>示例：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">swizzling</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//load方法会在类第一次加载的时候被调用</span></span><br><span class="line"><span class="comment">//调用的时间比较靠前，适合在这个方法里做方法交换</span></span><br><span class="line">+ (<span class="keyword">void</span>)load&#123;</span><br><span class="line">    <span class="comment">//方法交换应该被保证，在程序中只会执行一次</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">//获得viewController的生命周期方法的selector</span></span><br><span class="line">        SEL systemSel = <span class="keyword">@selector</span>(viewWillAppear:);</span><br><span class="line">        <span class="comment">//自己实现的将要被交换的方法的selector</span></span><br><span class="line">        SEL swizzSel = <span class="keyword">@selector</span>(swiz_viewWillAppear:);</span><br><span class="line">        <span class="comment">//两个方法的Method</span></span><br><span class="line">        Method systemMethod = class_getInstanceMethod([<span class="keyword">self</span> class], systemSel);</span><br><span class="line">        Method swizzMethod = class_getInstanceMethod([<span class="keyword">self</span> class], swizzSel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//首先动态添加方法，实现是被交换的方法，返回值表示添加成功还是失败</span></span><br><span class="line">        <span class="built_in">BOOL</span> isAdd = class_addMethod(<span class="keyword">self</span>, systemSel, method_getImplementation(swizzMethod), method_getTypeEncoding(swizzMethod));</span><br><span class="line">        <span class="keyword">if</span> (isAdd) &#123;</span><br><span class="line">            <span class="comment">//如果成功，说明类中不存在这个方法的实现</span></span><br><span class="line">            <span class="comment">//将被交换方法的实现替换到这个并不存在的实现</span></span><br><span class="line">            class_replaceMethod(<span class="keyword">self</span>, swizzSel, method_getImplementation(systemMethod), method_getTypeEncoding(systemMethod));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//否则，交换两个方法的实现</span></span><br><span class="line">            method_exchangeImplementations(systemMethod, swizzMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)swiz_viewWillAppear:(<span class="built_in">BOOL</span>)animated&#123;</span><br><span class="line">    <span class="comment">//这时候调用自己，看起来像是死循环</span></span><br><span class="line">    <span class="comment">//但是其实自己的实现已经被替换了</span></span><br><span class="line">    [<span class="keyword">self</span> swiz_viewWillAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"swizzle"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<h4 id="关联对象AssociatedObject">关联对象AssociatedObject</h4><p>常用于对象动态添加属性</p>
<ul>
<li>用给定的key和policy来为指定对象(object)设置关联对象值(value)</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key, id <span class="keyword">value</span>, objc_AssociationPolicy policy</span>)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>根据给定的key从指定对象(object)中获取相对应的关联对象值</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br></pre></td></tr></table></figure>
<ul>
<li>移除指定对象的全部关联对象</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="title">objc_removeAssociatedObjects</span><span class="params">(id object)</span></span></span><br></pre></td></tr></table></figure>
<p>注意点：</p>
<ul>
<li><code>*key</code>:使用<code>static char kAssociatedObjectKey</code> (&amp;kAssociatedObjectKey) 或者 @selector(associatedObject)／<code>_cmd</code></li>
</ul>
<p>示例: 为UITableView增加一个属性cellHeight</p>
<ul>
<li><code>AssociationPolicy</code>:</li>
</ul>
<p>定义</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>, //给关联对象指定弱引用,相当于@<span class="keyword">property</span><span class="title"></span>(assign)或@<span class="keyword">property</span><span class="title"></span>(unsafe_unretained)</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, //给关联对象指定非原子的强引用,相当于@<span class="keyword">property</span><span class="title"></span>(nonatomic,strong)或@<span class="keyword">property</span><span class="title"></span>(nonatomic,retain)</span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>, //给关联对象指定非原子的copy特性,相当于@<span class="keyword">property</span><span class="title"></span>(nonatomic,copy)</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>, //给关联对象指定原子强引用,相当于@<span class="keyword">property</span><span class="title"></span>(atomic,strong)或@<span class="keyword">property</span><span class="title"></span>(atomic,retain)</span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span> //给关联对象指定原子copy特性,相当于@<span class="keyword">property</span><span class="title"></span>(atomic,copy)</span><br><span class="line">&#125;;</span><br><span class="line">typedef uintptr_t objc_AssociationPolicy;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UITableView+Height.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UITableView</span> (<span class="title">Height</span>)</span></span><br><span class="line"><span class="comment">/** height */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> cellHeight;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//UITableView+Height.m</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"UITableView+HeightManager.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UITableView</span> (<span class="title">Height</span>)</span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)setCellHeight:(<span class="built_in">CGFloat</span>)cellHeight &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(cellHeight), @(cellHeight), OBJC_ASSO<span class="built_in">CIATION_ASSIGN_NONATOMIC</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)cellHeight &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> * number = objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">    <span class="keyword">return</span> number<span class="variable">.floatValue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>_cmd</code>在Objective-C的方法中表示当前方法的selector</p>
</blockquote>
<h4 id="遍历类中的所有成员变量_class_copyIvarList">遍历类中的所有成员变量 class_copyIvarList</h4><p>有时候我们要对一些信息进行归档，如用户信息类UserInfo，这将需要重写initWithCoder和encodeWithCoder方法，并对每个属性进行encode和decode操作。那么问题来了：当属性只有几个的时候可以轻松写完，如果有几十个属性呢？我们可以 用runtime提供的函数遍历Model自身所有属性，并对属性进行encode和decode操作。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount;</span><br><span class="line">        <span class="comment">//获得所传入类的成员变量</span></span><br><span class="line">        Ivar *ivars = class_copyIvarList([<span class="keyword">self</span> class], &amp;outCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">            Ivar ivar = ivars[i];</span><br><span class="line">            <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">            [<span class="keyword">self</span> setValue:[aDecoder decodeObjectForKey:key] forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">        free(ivars);<span class="comment">//别忘记释放</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount;</span><br><span class="line">    Ivar *ivars = class_copyIvarList([<span class="keyword">self</span> class], &amp;outCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">        Ivar ivar = ivars[i];</span><br><span class="line">        <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">        [aCoder encodeObject:[<span class="keyword">self</span> valueForKey:key] forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同理，字典转模型用的也是这种方法。</p>
</blockquote>
<h4 id="访问苹果私有属性_class_copyPropertyList">访问苹果私有属性 class_copyPropertyList</h4><p>利用runtime获取私有属性名</p>
<p>假设我们有一个需求，想改变输入框中占位文字的颜色，用runtime的这个作用可以让我们很方便的实现：</p>
<p>先将输入框所包含的属性打印出来：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)getProperties &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">objc_property_t</span> *properties = class_copyPropertyList([UITextField <span class="keyword">class</span>], &amp;count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">        <span class="comment">// 取出属性</span></span><br><span class="line">        <span class="keyword">objc_property_t</span> property = properties[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印属性名字</span></span><br><span class="line">        NSLog(@<span class="string">"%s   &lt;----&gt;   %s"</span>, property_getName(property), property_getAttributes(property));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到这样一个属性：<br><img src="http://static.open-open.com/lib/uploadImg/20161218/20161218094612_594.png" alt=""></p>
<p>顾名思义，这就是占位的Label，我们只要利用KVC就可以将其改成我们想要的样子：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">self</span> <span class="built_in">set</span>Value:[UIColor whiteColor] <span class="keyword">for</span>KeyPath:@<span class="string">"_placeholderLabel.textColor"</span>];</span><br></pre></td></tr></table></figure>
<h4 id="类簇Class_Clusters与runtime">类簇Class Clusters与runtime</h4><p>类簇是抽象工厂模式在iOS下的一种实现，众多常用类，如NSString，NSArray，NSDictionary，NSNumber都运作在这一模式下，它是接口简单性和扩展性的权衡体现，在我们完全不知情的情况下，偷偷隐藏了很多具体的实现类，只暴露出简单的接口。而利用runtime的NSClassFromString可以动态地实现类簇应用。</p>
<h6 id="runtime–NSClassFromString_结合类簇应用示例">runtime–NSClassFromString 结合类簇应用示例</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要求实现：iOS7显示私有类A的viewA，iOS8-10显示私有类B的viewB，iOS11显示私有类C的viewC</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClusterView</span> : <span class="title">UIView</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在ClusterView.m里创建3个私有类：ViewA、ViewB、ViewC</span></span><br><span class="line"><span class="comment">//ClustersView.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClusterView</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.常规方法：在ClusterView.m中重写alloc的方法</span></span><br><span class="line">+ (instancetype)alloc&#123;</span><br><span class="line">    <span class="keyword">if</span>([<span class="keyword">self</span> class] == [ClusterView class]) &#123;</span><br><span class="line">        <span class="keyword">float</span> v = [[[<span class="built_in">UIDevice</span> currentDevice] systemVersion] floatValue];</span><br><span class="line">        <span class="keyword">if</span>(v &lt;= <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="comment">//iOS7</span></span><br><span class="line">            <span class="keyword">return</span> [ViewA alloc];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(v &gt;= <span class="number">8</span> &amp;&amp; v &lt;= <span class="number">10</span> ) &#123;</span><br><span class="line">            <span class="comment">//iOS8-10</span></span><br><span class="line">            <span class="keyword">return</span> [ViewB alloc];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//iOS11</span></span><br><span class="line">            <span class="keyword">return</span> [ViewC alloc];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> alloc];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.利用runtime，重写init方法</span></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">float</span> v = [[[<span class="built_in">UIDevice</span> currentDevice] systemVersion] floatValue];</span><br><span class="line">        <span class="built_in">NSString</span> *className = <span class="string">@"ViewC"</span>;</span><br><span class="line">        <span class="keyword">if</span>(v &lt;= <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="comment">//iOS7</span></span><br><span class="line">            className = <span class="string">@"ViewA"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(v &gt;= <span class="number">8</span> &amp;&amp; v &lt;= <span class="number">10</span> ) &#123;</span><br><span class="line">            <span class="comment">//iOS8-10</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"ViewB"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Class class = <span class="built_in">NSClassFromString</span>(className);</span><br><span class="line">        <span class="keyword">self</span> = [[class alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for iOS7</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewA</span> : <span class="title">ClusterView</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewA</span></span></span><br><span class="line">- (<span class="keyword">void</span>)drawRect: (<span class="built_in">CGRect</span>)rect&#123;</span><br><span class="line">    <span class="comment">/* Custom iOS7 drawing code */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for iOS8-10</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewB</span> : <span class="title">ClusterView</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewB</span></span></span><br><span class="line">- (<span class="keyword">void</span>)drawRect: (<span class="built_in">CGRect</span>)rect&#123;</span><br><span class="line">    <span class="comment">/* Custom iOS8-11 drawing code */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for iOS11</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewC</span> : <span class="title">ClusterView</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewC</span></span></span><br><span class="line">- (<span class="keyword">void</span>)drawRect: (<span class="built_in">CGRect</span>)rect&#123;</span><br><span class="line">    <span class="comment">/* Custom iOS11 drawing code */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h6 id="参考资料">参考资料</h6><blockquote>
<p><a href="https://juejin.im/entry/59888a8d6fb9a03c5e4408a3" target="_blank" rel="external">https://juejin.im/entry/59888a8d6fb9a03c5e4408a3</a><br><a href="https://github.com/maligh/ML-Objective-C-Demo/blob/master/MessageForwarding" target="_blank" rel="external">https://github.com/maligh/ML-Objective-C-Demo/blob/master/MessageForwarding</a><br><a href="http://blog.csdn.net/yst19910702/article/details/51443901" target="_blank" rel="external">http://blog.csdn.net/yst19910702/article/details/51443901</a><br><a href="https://www.jianshu.com/p/8036f15c91c6" target="_blank" rel="external">https://www.jianshu.com/p/8036f15c91c6</a><br><a href="http://blog.devzeng.com/blog/ios-class-cluster-design-pattern.html" target="_blank" rel="external">http://blog.devzeng.com/blog/ios-class-cluster-design-pattern.html</a><br><a href="http://www.cocoachina.com/ios/20150104/10826.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20150104/10826.html</a><br><a href="http://nshipster.com/method-swizzling/" target="_blank" rel="external">http://nshipster.com/method-swizzling/</a><br><a href="http://nshipster.com/associated-objects/" target="_blank" rel="external">http://nshipster.com/associated-objects/</a><br><a href="http://blog.devzeng.com/blog/oc-associated-objects.html" target="_blank" rel="external">http://blog.devzeng.com/blog/oc-associated-objects.html</a><br><a href="https://www.jianshu.com/p/872447c6dc3f" target="_blank" rel="external">https://www.jianshu.com/p/872447c6dc3f</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="简介">简介</h4><p>Objective-C 是一门动态语言，它的动态性体现在它将很多编译和链接时做的事推延到运行时处理，而这一机制主要依赖系统提供的 runtime 库。利用 runtime 库，我们能在运行时做很多事，例如 objc_setAssocia]]>
    </summary>
    
      <category term="Objective-C" scheme="https://litt1e-p.github.io/tags/Objective-C/"/>
    
      <category term="Runtime" scheme="https://litt1e-p.github.io/tags/Runtime/"/>
    
      <category term="method swizzling" scheme="https://litt1e-p.github.io/tags/method-swizzling/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Timer]]></title>
    <link href="https://litt1e-p.github.io/2017/03/04/Timer/"/>
    <id>https://litt1e-p.github.io/2017/03/04/Timer/</id>
    <published>2017-03-04T11:17:57.000Z</published>
    <updated>2018-03-04T11:19:36.813Z</updated>
    <content type="html"><![CDATA[<h2 id="定时器">定时器</h2><h4 id="1-_RunLoop定时器">1. RunLoop定时器</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方法 手动加入runloop</span></span><br><span class="line">NSTimer *timer = [NSTimer <span class="string">timerWithTimeInterval:</span><span class="number">2.0</span> <span class="string">target:</span>self <span class="string">selector:</span><span class="annotation">@selector</span>(action) <span class="string">userInfo:</span>nil <span class="string">repeats:</span>YES];</span><br><span class="line"></span><br><span class="line">[[NSRunLoop currentRunLoop] <span class="string">addTimer:</span>timer <span class="string">forMode:</span>NSDefaultRunLoopMode];<span class="comment">//默认模式</span></span><br><span class="line">[[NSRunLoop currentRunLoop] <span class="string">addTimer:</span>timer <span class="string">forMode:</span>UITrackingRunLoopMode];<span class="comment">//页面追踪模式</span></span><br><span class="line">[[NSRunLoop currentRunLoop] <span class="string">addTimer:</span>timer <span class="string">forMode:</span>NSRunLoopCommonModes]; <span class="comment">//common模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方法 自动加入runloop(NSDefaultRunLoopMode)</span></span><br><span class="line">NSTimer *timer = [NSTimer <span class="string">scheduledTimerWithTimeInterval:</span><span class="number">2.0</span> <span class="string">target:</span>self <span class="string">selector:</span><span class="annotation">@selector</span>(<span class="string">action:</span>) <span class="string">userInfo:</span>nil <span class="string">repeats:</span>NO];</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line">[timer invalidate];</span><br></pre></td></tr></table></figure>
<h6 id="特点">特点</h6><ul>
<li>存在延迟</li>
</ul>
<p>不管是一次性的还是周期性的timer的实际触发事件的时间，都会与所加入的RunLoop和RunLoop Mode有关，如果此RunLoop正在执行一个连续性的运算，timer就会被延时出发。重复性的timer遇到这种情况，如果延迟超过了一个周期，则会在延时结束后立刻执行，并按照之前指定的周期继续执行。</p>
<ul>
<li>必须加入Runloop(手动或自动)</li>
</ul>
<h4 id="2-_GCD定时器">2. GCD定时器</h4><ul>
<li>循环timer</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> 1.创建GCD中的定时器</span><br><span class="line"> <span class="doctag">@param</span> DISPATCH_SOURCE_TYPE_TIMER source的类型，表示是定时器</span><br><span class="line"> <span class="doctag">@param</span> 0 描述信息，线程ID</span><br><span class="line"> <span class="doctag">@param</span> 0 更详细的描述信息</span><br><span class="line"> <span class="doctag">@param</span> dispatchQueue 队列，确定GCD定时器中的任务在哪个线程中执行</span><br><span class="line"> */</span></span><br><span class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> 2.设置定时器（起始时间|间隔时间|精准度）</span><br><span class="line"> <span class="doctag">@param</span> timer 定时器对象</span><br><span class="line"> <span class="doctag">@param</span> DISPATCH_TIME_NOW 起始时间，DISPATCH_TIME_NOW 从现在开始计时</span><br><span class="line"> <span class="doctag">@param</span> intervalInSeconds * NSEC_PER_SEC 间隔时间</span><br><span class="line"> <span class="doctag">@param</span> leewayInSeconds * NSEC_PER_SEC 精准度，绝对精准0</span><br><span class="line"> */</span></span><br><span class="line">dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, <span class="number">2.0</span> * NSEC_PER_SEC, <span class="number">0</span> * NSEC_PER_SEC);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.设置定时器执行的任务</span></span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"------------%@"</span>, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.启动执行</span></span><br><span class="line">dispatch_resume(timer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.暂停</span></span><br><span class="line">dispatch_suspend(timer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.释放</span></span><br><span class="line">dispatch_source_cancel(timer);</span><br></pre></td></tr></table></figure>
<ul>
<li>单次timer</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">dispatch_after</span>(<span class="function">dispatch_time</span>(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * NSEC_PER_SEC)), <span class="tag">dispatch_get_main_queue</span>(), ^(void)&#123;</span><br><span class="line">    <span class="attr_selector">[self action]</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h6 id="特点-1">特点</h6><p>GCD定时器和NSTimer是不一样的，NSTimer受RunLoop影响，但是GCD的定时器不受影响，因为通过源码可知RunLoop也是基于GCD的实现的，所以GCD定时器有非常高的精度</p>
<h4 id="3-_CADisplayLink">3. CADisplayLink</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CADisplayLink *displayLink = [CADisplayLink <span class="string">displayLinkWithTarget:</span>self <span class="string">selector:</span><span class="annotation">@selector</span>(<span class="string">action:</span>)];  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 每隔2帧调用一次</span></span><br><span class="line">displayLink.frameInterval = <span class="number">2</span>;  </span><br><span class="line"></span><br><span class="line">[displayLink <span class="string">addToRunLoop:</span>[NSRunLoop currentRunLoop] <span class="string">forMode:</span>NSDefaultRunLoopMode];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line">[displayLink invalidate];</span><br></pre></td></tr></table></figure>
<h6 id="特点-2">特点</h6><ul>
<li>刷新频率固定</li>
</ul>
<p>正常情况iOS设备的屏幕刷新频率是固定60Hz,如果CPU过于繁忙，无法保证屏幕60次/秒的刷新率，就会导致跳过若干次调用回调方法的机会，跳过次数取决CPU的忙碌程度。</p>
<ul>
<li>屏幕刷新时调用</li>
</ul>
<p>CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。但如果调用的方法比较耗时，超过了屏幕刷新周期，就会导致跳过若干次回调调用机会</p>
<ul>
<li>适合做界面渲染</li>
</ul>
<p>CADisplayLink可以确保系统渲染每一帧的时候我们的方法都被调用，从而保证了动画的流畅性</p>
<hr>
<h6 id="参考资料">参考资料</h6><blockquote>
<p><a href="https://www.jianshu.com/p/21d351116587" target="_blank" rel="external">https://www.jianshu.com/p/21d351116587</a><br><a href="http://www.bijishequ.com/detail/234634" target="_blank" rel="external">http://www.bijishequ.com/detail/234634</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="定时器">定时器</h2><h4 id="1-_RunLoop定时器">1. RunLoop定时器</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span clas]]>
    </summary>
    
      <category term="RunLoop" scheme="https://litt1e-p.github.io/tags/RunLoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Singleton]]></title>
    <link href="https://litt1e-p.github.io/2017/01/05/Singleton/"/>
    <id>https://litt1e-p.github.io/2017/01/05/Singleton/</id>
    <published>2017-01-05T12:52:38.000Z</published>
    <updated>2018-03-07T12:32:59.948Z</updated>
    <content type="html"><![CDATA[<h4 id="Objective-C">Objective-C</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Singleton.h</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Singleton</span> : <span class="title">NSObject</span>&lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line">+(instancetype)shared;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Singleton.m</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"Singleton.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Singleton</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Singleton *_instance = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">+ (instancetype)shared &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken,^&#123;</span><br><span class="line">        _instance = [[<span class="keyword">super</span> allocWithZone:<span class="literal">NULL</span>]init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)allocWithZone:(<span class="keyword">struct</span> _<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    <span class="keyword">return</span> [Singleton shared];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    <span class="keyword">return</span> [Singleton shared];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>记得遵循NSCopying协议</p>
</blockquote>
<h4 id="Swift">Swift</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can't init is singleton</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">Singleton</span>()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Singleton_宏">Singleton 宏</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">//for .h</span><br><span class="line"><span class="comment">#define SYNTHESIZE_SINGLETON_FOR_HEADER(classname)\</span></span><br><span class="line">+ (classname *)shared<span class="comment">##classname;</span></span><br><span class="line"></span><br><span class="line">//</span><span class="keyword">for</span> .m</span><br><span class="line"><span class="comment">#define SYNTHESIZE_SINGLETON_FOR_CLASS(classname) \</span></span><br><span class="line"><span class="string">\</span></span><br><span class="line">static classname *shared<span class="comment">##classname = nil; \</span></span><br><span class="line"><span class="string">\</span></span><br><span class="line">+ (classname *)shared<span class="comment">##classname \</span></span><br><span class="line">&#123; <span class="string">\</span></span><br><span class="line"><span class="property">@synchronized</span>(self) <span class="string">\</span></span><br><span class="line">&#123; <span class="string">\</span></span><br><span class="line"><span class="keyword">if</span> (shared<span class="comment">##classname == nil) \</span></span><br><span class="line">&#123; <span class="string">\</span></span><br><span class="line">shared<span class="comment">##classname = [[super allocWithZone:NULL] init]; \</span></span><br><span class="line">&#125; <span class="string">\</span></span><br><span class="line">&#125; <span class="string">\</span></span><br><span class="line"><span class="string">\</span></span><br><span class="line"><span class="keyword">return</span> shared<span class="comment">##classname; \</span></span><br><span class="line">&#125; <span class="string">\</span></span><br><span class="line"><span class="string">\</span></span><br><span class="line">+ (id)<span class="attribute">allocWithZone</span>:(NSZone *)zone <span class="string">\</span></span><br><span class="line">&#123; <span class="string">\</span></span><br><span class="line"><span class="keyword">return</span> [self shared<span class="comment">##classname];\</span></span><br><span class="line">&#125; <span class="string">\</span></span><br><span class="line"><span class="string">\</span></span><br><span class="line">- (id)<span class="attribute">copyWithZone</span>:(NSZone *)zone <span class="string">\</span></span><br><span class="line">&#123; <span class="string">\</span></span><br><span class="line"><span class="keyword">return</span> self; <span class="string">\</span></span><br><span class="line">&#125; <span class="string">\</span></span><br><span class="line"><span class="string">\</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="Objective-C">Objective-C</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br>]]>
    </summary>
    
      <category term="Objective-C" scheme="https://litt1e-p.github.io/tags/Objective-C/"/>
    
      <category term="Singleton" scheme="https://litt1e-p.github.io/tags/Singleton/"/>
    
      <category term="swift" scheme="https://litt1e-p.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GCD]]></title>
    <link href="https://litt1e-p.github.io/2016/12/29/GCD/"/>
    <id>https://litt1e-p.github.io/2016/12/29/GCD/</id>
    <published>2016-12-29T13:18:27.000Z</published>
    <updated>2018-03-07T12:53:05.894Z</updated>
    <content type="html"><![CDATA[<h4 id="队列_Dispatch_Queue">队列 Dispatch Queue</h4><ul>
<li>串行队列 Serial Dispatch Queue, 先进先出执行(FIFO)</li>
<li>并行队列 Concurrent Dispatch Queue</li>
</ul>
<blockquote>
<p>串行队列只有一个线程，并行队列有多个线程</p>
</blockquote>
<h4 id="建立Queue">建立Queue</h4><ul>
<li>自建Queue</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.mac.queue"</span>, DISPATCH_QUEUE_SERIAL);<span class="comment">//创建了一个串行队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.mac.queue"</span>, DISPATCH_QUEUE_CONCURRENT);<span class="comment">//创建了一个并行队列</span></span><br></pre></td></tr></table></figure>
<ul>
<li>系统Queue</li>
</ul>
<p>1.<code>Main Dispatch Queue</code>: 在主线程中执行的队列。因为主线程只有1个，所以<code>Main Dispatch Queue</code>是串行队列。加入到主队列中的任务一定不会生成新的线程，因为主队列必须有且只有一条主线程。</p>
<p>2.<code>Global Dispatch Queue</code>: 一个所有应用程序都能够使用的并发队列。加入到该队列中的任务不一定会生成线程。因为有线程重用的现象。</p>
<h4 id="dispatch_sync和dispatch_async">dispatch_sync和dispatch_async</h4><ul>
<li>dispatch_sync</li>
</ul>
<p>dispatch_sync将指定的Block同步的追加到指定的Dispatch Queue。此时dispatch_sync会一直等待Block执行结束之后，才会返回。线程才能接着继续执行其他代码。</p>
<ul>
<li>dispatch_async</li>
</ul>
<p>dispatch_async将指定的Block异步的追加到指定的Dispatch Queue中。dispatch_async函数不会做任何等待。<br>dispatch_async代表异步任务，意思不是一定会生成一条线程。如果在MainQueue中执行，则不会生成线程；如果在Global Queue中有可能会生成。因为线程有一个线程池，会重用已经完成任务了的线程。</p>
<h4 id="任务组_Dispatch_Group">任务组 Dispatch Group</h4><p><code>dispatch_group</code>是GCD的一项特性，能够把任务分组。调用者可以等待这组任务执行完毕，也可以提供回调函数之后继续往下执行，这组任务完成时，调用者会得到通知。常用场景比如说，下载一个大的文件，分块下载，全部下载完成后再合成一个文件。再比如同时下载多个图片，监听全部下载完后的动作。</p>
<ul>
<li>创建group</li>
</ul>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t <span class="keyword">group</span> <span class="title">= dispatch_group_create</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>添加任务</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将一个任务添加到指定group中</span></span><br><span class="line">dispatch_group_async(<span class="keyword">dispatch_group_t</span> group, <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">dispatch_block_t</span> block);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这两个函数同上边一样的效果，不过一定要注意这两个函数必须成对出现！否则这一组任务就永远执行不完。</span></span><br><span class="line">dispatch_group_enter(<span class="keyword">dispatch_group_t</span> group);</span><br><span class="line">dispatch_group_leave(<span class="keyword">dispatch_group_t</span> group);</span><br></pre></td></tr></table></figure>
<ul>
<li>监听任务完成</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_notify(<span class="keyword">dispatch_group_t</span> group, <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">dispatch_block_t</span> block);</span><br><span class="line"><span class="comment">//开发者可以传入block，等dispatch group 执行完毕之后，块会在特定的线程上执行，而不阻塞线程。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dispatch_group_wait</span><span class="params">(dispatch_group_t group, dispatch_time_t timeout)</span></span>;</span><br><span class="line"><span class="comment">//timeout参数表示函数在等待dispatch group执行完毕后，应该阻塞多久。如果执行dispatch group所需的时间小于timeout，则返回0，否则返回非0值.此参数可以取常量DISPATCH_TIME_FOREVER，这表示函数会一直等着dispatch group 执行完，而不会超时。此方法会阻塞线程。</span></span><br></pre></td></tr></table></figure>
<p>示例：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();</span><br><span class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟多线程耗时操作1</span></span><br><span class="line">dispatch_group_enter(<span class="keyword">group</span>);</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, globalQueue, ^&#123;    </span><br><span class="line">    sleep(<span class="number">3</span>);    </span><br><span class="line">    NSLog(@<span class="string">"%@---block1结束"</span>, [NSThread currentThread]);    </span><br><span class="line">    dispatch_group_leave(<span class="keyword">group</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟多线程耗时操作2</span></span><br><span class="line">dispatch_group_enter(<span class="keyword">group</span>);</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, globalQueue, ^&#123;    </span><br><span class="line">    sleep(<span class="number">3</span>);    </span><br><span class="line">    NSLog(@<span class="string">"%@---block2结束"</span>, [NSThread currentThread]);    </span><br><span class="line">    dispatch_group_leave(<span class="keyword">group</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.使用dispatch_group_notify</span></span><br><span class="line">dispatch_group_notify(<span class="keyword">group</span>, dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"%@---全部结束"</span>,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用dispatch_group_wait</span></span><br><span class="line">dispatch_group_wait(<span class="keyword">group</span>, DISPATCH_TIME_FOREVER) <span class="comment">// dispatch_group_wait阻塞当前进程，会等待所有任务都完成直到超时。如果任务完成前就超时了，函数会返回一个非零值，可以通过返回值判断是否超时。也可以用DISPATCH_TIME_FOREVER表示一直等。</span></span><br><span class="line">NSLog(@<span class="string">"%@---全部结束"</span>,[NSThread currentThread]);</span><br></pre></td></tr></table></figure></p>
<h4 id="dispatch_set_target_queue设置优先级">dispatch_set_target_queue设置优先级</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将myQueue优先级设置为与globalQueue相同</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> myQueue = dispatch_queue_create(<span class="string">"com.gcd.queue"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> globalQueue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, <span class="number">0</span>);</span><br><span class="line">dispatch_set_target_queue(myQueue, globalQueue)</span><br></pre></td></tr></table></figure>
<h4 id="栅栏(dispatch_barrier_sync和dispatch_barrier_async)">栅栏(dispatch_barrier_sync和dispatch_barrier_async)</h4><p>作用：与并发队列结合，可以高效率的避免数据竞争的问题</p>
<p>相同点：<code>dispatch_barrier_sync</code>和<code>dispatch_barrier_async</code>函数功能一样就是在并发队列中将此代码插入的地方上下隔开，如果栅栏一样，两部分不影响。只有上边的并发队列都执行结束之后，下边的并发队列才能够执行。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/16/160ff2d8cb6ef975?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>不同点:<code>dispatch_barrier_sync</code>代码后边的任务直到<code>dispatch_barrier_sync</code>执行完才能被追加到队列中；<code>dispatch_barrier_async</code>不用代码执行完，后边的任务也会被追加到队列中。代码上的体现就是<code>dispatch_barrier_sync</code>后边的代码不会执行，<code>dispatch_barrier_async</code>后边的代码会执行，但是Block不会被执行。</p>
<p>dispatch_barrier_async函数的作用与barrier的意思相同,在进程管理中起到一个栅栏的作用,它等待所有位于barrier函数之前的操作执行完毕后执行,并且在barrier函数执行之后,barrier函数之后的操作才会得到执行,<code>该函数需要同dispatch_queue_create函数生成的concurrent Dispatch Queue队列一起使用</code>，否则与dispatch_barrier_sync无异。</p>
<p>示例：</p>
<ul>
<li>dispatch_barrier_sync</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同dispatch_queue_create函数生成的concurrent Dispatch Queue队列一起使用</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.barrier.async"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"----1-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"----2-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_barrier_sync(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"----barrier-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"🎈🎈🎈"</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"----3-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"🎉🎉🎉"</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"----4-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>输出结果:1 2 –&gt; barrier –&gt; 🎈🎈🎈 🎉🎉🎉 –&gt;3 4。</p>
<ul>
<li>dispatch_barrier_async</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同dispatch_queue_create函数生成的concurrent Dispatch Queue队列一起使用</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.barrier.async"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"----1-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"----2-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"----barrier-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"🎈🎈🎈"</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"----3-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"🎉🎉🎉"</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"----4-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>输出结果:1 2 –&gt; 🎈🎈🎈 🎉🎉🎉–&gt; barrier –&gt;3 4  其中12 与 34 由于并行处理先后顺序不定。</p>
<h4 id="dispatch_apply_快速遍历">dispatch_apply 快速遍历</h4><p>类似for循环，但是在并发队列的情况下dispatch_apply会并发执行block任务。<br>dispatch_apply能避免线程爆炸，因为GCD会管理并发</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)run:(<span class="built_in">BOOL</span>)explode &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.concurrentqueue"</span>,DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="keyword">if</span> (explode) &#123;</span><br><span class="line">        <span class="comment">//传统for循环，有问题的情况，可能会死锁</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999</span> ; i++) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"wrong %d"</span>,i);</span><br><span class="line">                <span class="comment">//do something</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//dispatch_apply会优化很多，能够利用GCD管理</span></span><br><span class="line">        dispatch_apply(<span class="number">999</span>, concurrentQueue, ^(size_t i)&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"correct %zu"</span>,i);</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"The end"</span>); <span class="comment">//这里有个需要注意的是，dispatch_apply这个是会阻塞主线程的。这个log打印会在dispatch_apply都结束后才开始执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">downloadPhotosWithCompletion</span><span class="params">(completion: CompletionClosure?)</span></span> &#123;</span><br><span class="line">     <span class="keyword">var</span> storedError: <span class="type">NSError</span>!</span><br><span class="line">     <span class="keyword">var</span> downloadGroup = dispatch_group_create()</span><br><span class="line">     <span class="keyword">let</span> urls = [url1, url2, url3]</span><br><span class="line"></span><br><span class="line">     dispatch_apply(<span class="type">UInt</span>(urls.<span class="built_in">count</span>), <span class="type">GlobalUserInitiatedQueue</span>) &#123;</span><br><span class="line">          i <span class="keyword">in</span></span><br><span class="line">          <span class="keyword">let</span> index = <span class="type">Int</span>(i)</span><br><span class="line">          <span class="keyword">let</span> address = urls[index]</span><br><span class="line">          <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: address)</span><br><span class="line">          dispatch_group_enter(downloadGroup)</span><br><span class="line">          <span class="keyword">let</span> photo = <span class="type">DownloadPhoto</span>(url: url!) &#123;</span><br><span class="line">               image, error <span class="keyword">in</span></span><br><span class="line">               <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</span><br><span class="line">                    storedError = error</span><br><span class="line">               &#125;</span><br><span class="line">               dispatch_group_leave(downloadGroup)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">PhotoManager</span>.sharedManager.addPhoto(photo)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     dispatch_group_notify(downloadGroup, <span class="type">GlobalMainQueue</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">let</span> completion = completion &#123;</span><br><span class="line">               completion(error: storedError)</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Dispatch_Block_调度块">Dispatch Block 调度块</h4><p>队列执行任务都是block的方式</p>
<ul>
<li>创建block</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//normal way</span><br><span class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create<span class="list">(<span class="string">"com.mac.gcd.block"</span>,DISPATCH_QUEUE_CONCURRENT)</span><span class="comment">;</span></span><br><span class="line">dispatch_block_t block = dispatch_block_create<span class="list">(<span class="number">0</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"run block"</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">concurrentQueue</span>, block)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">//QOS way</span><br><span class="line">dispatch_block_t qosBlock = dispatch_block_create_with_qos_class<span class="list">(<span class="number">0</span>, QOS_CLASS_USER_INITIATED, <span class="number">-1</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"run qos block"</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">concurrentQueue</span>, qosBlock)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>dispatch_block_wait</li>
</ul>
<p>可以根据dispatch block来设置等待时间，参数DISPATCH_TIME_FOREVER会一直等待block结束</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ispatch_queue_t serialQueue = dispatch_queue_create(<span class="string">"com.mac.gcd.block"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_block_t block = dispatch_block_create(<span class="number">0</span>, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"start"</span>);</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5.</span>f];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"end"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(serialQueue, block);</span><br><span class="line"><span class="comment">//设置DISPATCH_TIME_FOREVER会一直等到前面任务都完成</span></span><br><span class="line">dispatch_block_wait(block, DISPATCH_TIME_FOREVER);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"ok, now can go on"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>dispatch_block_notify</li>
</ul>
<p>可以监视指定dispatch block结束，然后再加入一个block到队列中。三个参数分别为，第一个是需要监视的block，第二个参数是执行的队列，第三个是待加入到队列中的block</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.mac.gcd.block"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="keyword">dispatch_block_t</span> firstBlock = dispatch_block_create(<span class="number">0</span>, ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"first block start"</span>);</span><br><span class="line">    [NSThread sleepForTimeInterval:<span class="number">2.f</span>];</span><br><span class="line">    NSLog(@<span class="string">"first block end"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(serialQueue, firstBlock);</span><br><span class="line"><span class="keyword">dispatch_block_t</span> secondBlock = dispatch_block_create(<span class="number">0</span>, ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"second block run"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//first block执行完才在serial queue中执行second block</span></span><br><span class="line">dispatch_block_notify(firstBlock, serialQueue, secondBlock);</span><br></pre></td></tr></table></figure>
<ul>
<li>dispatch_block_cancel</li>
</ul>
<p>iOS8后GCD支持对dispatch block的取消</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.mac.gcd.block"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_block_t firstBlock = dispatch_block_create(<span class="number">0</span>, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"first block start"</span>);</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.</span>f];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"first block end"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_block_t secondBlock = dispatch_block_create(<span class="number">0</span>, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"second block run"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(serialQueue, firstBlock);</span><br><span class="line"><span class="built_in">dispatch_async</span>(serialQueue, secondBlock);</span><br><span class="line"><span class="comment">//取消secondBlock</span></span><br><span class="line">dispatch_block_cancel(secondBlock);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个只能发生在block还在队列中并没有开始的情况下。因为把block已经放到了async异步调用中，所以这个地方会先执行，执行完了才会执行block</p>
</blockquote>
<h4 id="Dispatch_Semaphore">Dispatch Semaphore</h4><p>一种保证同步的方法。使用dispatch_semaphore_signal加1dispatch_semaphore_wait减1，为0时等待的设置方式来达到线程同步的目的和同步锁一样能够解决资源抢占的问题。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建semaphore</span></span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"start"</span>);</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.</span>f];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"semaphore +1"</span>);</span><br><span class="line">    dispatch_semaphore_signal(semaphore); <span class="comment">//+1 semaphore</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"continue"</span>);</span><br><span class="line"><span class="comment">//打印："start --&gt; semaphore +1 --&gt; continue"</span></span><br></pre></td></tr></table></figure>
<h4 id="GCD死锁">GCD死锁</h4><p><code>当前串行队列</code>里面<code>同步</code>执行<code>当前串行队列</code>就会死锁，解决的方法就是将同步的串行队列放到另外一个线程就能够解决。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子1</span></span><br><span class="line"><span class="comment">//主队列的同步线程，按照FIFO的原则（先入先出），2排在3后面会等3执行完，但因为同步线程，3又要等2执行完，相互等待成为死锁。</span></span><br><span class="line"><span class="comment">// 此处的当前串行队列为main_queue（主线程），而`dispatch_get_main_queue`又是主线程，所以会死锁</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子2</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</span><br><span class="line">    <span class="comment">// 此处的当前队列为global_queue（全局并发队列），而`dispatch_get_main_queue`是主线程，所以不会死锁</span></span><br><span class="line">    <span class="comment">//将同步的串行队列放到另外一个线程就能够解决</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"4"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"5"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子3</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.mac.gcd.serialqueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</span><br><span class="line">    <span class="comment">//串行队列里面同步同一个串行队列就会死锁</span></span><br><span class="line">    <span class="comment">// 此处的当前串行队列为serialQueue（串行队列），而`dispatch_sync`又是在同一个serialQueue，所以会死锁</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(serialQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"4"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"5"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子4</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.mac.gcd.serialqueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</span><br><span class="line">    <span class="comment">//串行队列里面同步不同的串行队列不会死锁</span></span><br><span class="line">    <span class="comment">// 此处的当前串行队列为serialQueue（串行队列），而`dispatch_sync`在另一个串行队列里（dispatch_get_main_queue），所以不会死锁</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"4"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"5"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="dispatch_once">dispatch_once</h4><p>dispatch_once_t要是全局或static变量，保证dispatch_once_t只有一份实例</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只运行一次</span></span><br><span class="line">+ (<span class="keyword">id</span>)shareInstance &#123;</span><br><span class="line">    <span class="keyword">static</span> TestClass *shareInstance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        shareInstance = [[TestClass alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">   <span class="keyword">return</span> shareInstance;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="dispatch_after">dispatch_after</h4><p>dispatch_after只是延时提交block，不是延时立刻执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> delayInSeconds = <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">dispatch_time_t</span> popTime = dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>) (delayInSeconds * NSEC_PER_SEC));</span><br><span class="line">dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="dispatch_suspend和dispatch_resume挂起和恢复队列">dispatch_suspend和dispatch_resume挂起和恢复队列</h4><p>dispatch_suspend这里挂起不会暂停正在执行的block，只是能够暂停还没执行的block</p>
<h6 id="参考资料">参考资料</h6><blockquote>
<p><a href="http://blog.csdn.net/u013046795/article/details/47057585" target="_blank" rel="external">http://blog.csdn.net/u013046795/article/details/47057585</a><br><a href="https://github.com/ming1016/study/wiki/%E7%BB%86%E8%AF%B4GCD%EF%BC%88Grand-Central-Dispatch%EF%BC%89%E5%A6%82%E4%BD%95%E7%94%A8" target="_blank" rel="external">https://github.com/ming1016/study/wiki/%E7%BB%86%E8%AF%B4GCD%EF%BC%88Grand-Central-Dispatch%EF%BC%89%E5%A6%82%E4%BD%95%E7%94%A8</a><br><a href="https://juejin.im/post/5a5dff6a518825732c538dce" target="_blank" rel="external">https://juejin.im/post/5a5dff6a518825732c538dce</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="队列_Dispatch_Queue">队列 Dispatch Queue</h4><ul>
<li>串行队列 Serial Dispatch Queue, 先进先出执行(FIFO)</li>
<li>并行队列 Concurrent Dispatch Queue</]]>
    </summary>
    
      <category term="GCD" scheme="https://litt1e-p.github.io/tags/GCD/"/>
    
      <category term="Objective-C" scheme="https://litt1e-p.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[change statusBar backgroundColor]]></title>
    <link href="https://litt1e-p.github.io/2016/12/03/change-statusBar-backgroundColor/"/>
    <id>https://litt1e-p.github.io/2016/12/03/change-statusBar-backgroundColor/</id>
    <published>2016-12-03T13:31:23.000Z</published>
    <updated>2016-12-03T13:32:25.000Z</updated>
    <content type="html"><![CDATA[<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//for swift</span></span><br><span class="line"></span><br><span class="line">let statWindow = <span class="built_in">UIApplication</span><span class="variable">.shared</span><span class="variable">.value</span>(forKey:<span class="string">"statusBarWindow"</span>) as! <span class="built_in">UIView</span></span><br><span class="line"></span><br><span class="line">let statusBar = statWindow<span class="variable">.subviews</span>[<span class="number">0</span>] as <span class="built_in">UIView</span></span><br><span class="line"></span><br><span class="line">statusBar<span class="variable">.backgroundColor</span> = <span class="built_in">UIColor</span><span class="variable">.red</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for Objective-C</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UIView</span> *statusWindow = [[<span class="built_in">UIApplication</span> sharedApplication] valueForKey:<span class="string">@"statusBarWindow"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIView</span> *statusBar = statusWindow<span class="variable">.subviews</span><span class="variable">.firstObject</span>;</span><br><span class="line"></span><br><span class="line">statusBar<span class="variable">.backgroundColor</span> = <span class="keyword">self</span><span class="variable">.statusBarBackgroundColor</span>;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span ]]>
    </summary>
    
      <category term="Note" scheme="https://litt1e-p.github.io/tags/Note/"/>
    
      <category term="Objective-C" scheme="https://litt1e-p.github.io/tags/Objective-C/"/>
    
      <category term="swift" scheme="https://litt1e-p.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[autoLayout for UIScrollView in Xib]]></title>
    <link href="https://litt1e-p.github.io/2016/11/26/autoLayout-for-UIScrollView-in-Xib/"/>
    <id>https://litt1e-p.github.io/2016/11/26/autoLayout-for-UIScrollView-in-Xib/</id>
    <published>2016-11-26T07:31:27.000Z</published>
    <updated>2016-11-26T07:32:46.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Using UIScrollView in Xib or storyBoard is quite normal and frequent, but it is a little complicated by using autoLayout because of the complicated scrollView’s contentSize and contentInsets</p>
</blockquote>
<p>let’s begin</p>
<h4 id="1-0_initial_a_scrollView">1.0 initial a scrollView</h4><ul>
<li>new a project, drag a UIScrollView into Storyboard or Xib and make some constraints:</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1418424-8450a58e55abcf98.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1418424-5881ada668a2f949.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="2-0_add_a_contenView">2.0 add a contenView</h4><ul>
<li>2.1 drag an UIView named: <code>containView</code> into scrollView and add the edge constraints. the contentSize of scrollView depend on this <code>containView</code> </li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1418424-21e23d2a8f18d687.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>by the way, Xcode interface builder will show some errors, just ignore them.</p>
<ul>
<li>2.2 add some extral constraints to <code>containView</code>  according to the scroll direction</li>
</ul>
<p>so firstly you should make sure that which scroll direction you want</p>
<p>you should not add the constraints like below shows if horizontal and vertical scroll direction are both wanted:</p>
<ul>
<li><p>2.2.1 add a <code>Horizontally in Container</code> and a <code>Vertically in Container</code> constraints</p>
</li>
<li><p>2.2.2 height or width constraints:</p>
</li>
</ul>
<p>for horizontal scroll direction: add a <code>width</code> constraint for <code>containView</code></p>
<p>for vertical scroll direction: add a <code>height</code> constraint for <code>containView</code></p>
<p>and done! 🎉🎉</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>Using UIScrollView in Xib or storyBoard is quite normal and frequent, but it is a little complicated by using autoLayout bec]]>
    </summary>
    
      <category term="Note" scheme="https://litt1e-p.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cannot convert value of type `SecTrustResultType` to expected argument type `UInt32`]]></title>
    <link href="https://litt1e-p.github.io/2016/11/17/Cannot-convert-value-of-type-SecTrustResultType-to-expected-argument-type-UInt32/"/>
    <id>https://litt1e-p.github.io/2016/11/17/Cannot-convert-value-of-type-SecTrustResultType-to-expected-argument-type-UInt32/</id>
    <published>2016-11-17T14:58:33.000Z</published>
    <updated>2016-11-17T15:00:06.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Cannot convert value of type ‘SecTrustResultType’ to expected argument type ‘UInt32’</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//error example: </span></span><br><span class="line"><span class="keyword">var</span> result = <span class="type">SecTrustResultType</span>(rawValue: <span class="type">SecTrustResultType</span>.<span class="type">Invalid</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//solution:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="type">SecTrustResultType</span>.<span class="type">Invalid</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// for other enum values</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//let unspecified = SecTrustResultType(rawValue: SecTrustResultType.Unspecified)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//let proceed = SecTrustResultType(rawValue: SecTrustResultType.Proceed)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> unspecified = <span class="type">SecTrustResultType</span>.<span class="type">Unspecified</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proceed = <span class="type">SecTrustResultType</span>.<span class="type">Proceed</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>Cannot convert value of type ‘SecTrustResultType’ to expected argument type ‘UInt32’</p>
</blockquote>
<figure class="highli]]>
    </summary>
    
      <category term="Note" scheme="https://litt1e-p.github.io/tags/Note/"/>
    
      <category term="swift" scheme="https://litt1e-p.github.io/tags/swift/"/>
    
  </entry>
  
</feed>
