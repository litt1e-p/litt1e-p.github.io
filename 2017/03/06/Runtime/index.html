<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Runtime | litt1e-p</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="简介Objective-C 是一门动态语言，它的动态性体现在它将很多编译和链接时做的事推延到运行时处理，而这一机制主要依赖系统提供的 runtime 库。利用 runtime 库，我们能在运行时做很多事，例如 objc_setAssociatedObject 动态绑定属性、method swizzling、class_copyIvarList 动态获取属性实现 ORM（Object Relatio">
<meta property="og:type" content="article">
<meta property="og:title" content="Runtime">
<meta property="og:url" content="https://litt1e-p.github.io/2017/03/06/Runtime/index.html">
<meta property="og:site_name" content="litt1e-p">
<meta property="og:description" content="简介Objective-C 是一门动态语言，它的动态性体现在它将很多编译和链接时做的事推延到运行时处理，而这一机制主要依赖系统提供的 runtime 库。利用 runtime 库，我们能在运行时做很多事，例如 objc_setAssociatedObject 动态绑定属性、method swizzling、class_copyIvarList 动态获取属性实现 ORM（Object Relatio">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/8/8/a65b266e187329db430c8120aab53ffc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/449095-3e972ec16703c54d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240/q/100">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20161218/20161218094612_594.png">
<meta property="og:updated_time" content="2018-04-09T03:56:54.903Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Runtime">
<meta name="twitter:description" content="简介Objective-C 是一门动态语言，它的动态性体现在它将很多编译和链接时做的事推延到运行时处理，而这一机制主要依赖系统提供的 runtime 库。利用 runtime 库，我们能在运行时做很多事，例如 objc_setAssociatedObject 动态绑定属性、method swizzling、class_copyIvarList 动态获取属性实现 ORM（Object Relatio">
  
    <link rel="alternative" href="/atom.xml" title="litt1e-p" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <section id="main"><article id="post-Runtime" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Runtime
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/03/06/Runtime/" class="article-date">
  <time datetime="2017-03-06T12:32:31.000Z" itemprop="datePublished">2017-03-06</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="简介">简介</h4><p>Objective-C 是一门动态语言，它的动态性体现在它将很多编译和链接时做的事推延到运行时处理，而这一机制主要依赖系统提供的 runtime 库。利用 runtime 库，我们能在运行时做很多事，例如 objc_setAssociatedObject 动态绑定属性、method swizzling、class_copyIvarList 动态获取属性实现 ORM（Object Relational Mapping）、消息转发等。</p>
<h4 id="消息转发">消息转发</h4><p>Objective-C 中的方法调用最终都是执行消息发送，如</p>
<p><code>[receiver message]</code></p>
<p>最后会转换成</p>
<p><code>objc_msgSend(receiver, selector)</code></p>
<p>如果 receiver 不响应 message 消息，则会去父类查找，父类还不响应继续去父类查找，如果一直查找到 NSObject 还不响应，则会进入消息动态处理流程。</p>
<h4 id="消息动态处理">消息动态处理</h4><p>如果一个类不响应某个具体的方法，在进入消息转发流程前还有两个时机处理，第一是询问是否有动态添加方法来进行处理（<code>resolveInstanceMethod/resolveClassMethod</code>）, 若没有则询问有没有别人能够帮忙处理一下啊，调用的是<code>forwardingTargetForSelector</code>这个方法。</p>
<ul>
<li>resolveInstanceMethod / resolveClassMethod</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="tag">BOOL</span>)<span class="tag">resolveInstanceMethod</span><span class="pseudo">:(SEL)sel</span>;</span><br><span class="line">+ (<span class="tag">BOOL</span>)<span class="tag">resolveClassMethod</span><span class="pseudo">:(SEL)sel</span>;</span><br></pre></td></tr></table></figure>
<p>在这个方法中我们可以利用runtime的特性动态添加方法来处理，具体如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A.m</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"sel is %@"</span>, <span class="built_in">NSStringFromSelector</span>(sel));</span><br><span class="line">    <span class="keyword">if</span>(sel == <span class="keyword">@selector</span>(setName:))&#123;</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> class], sel, (IMP)a,<span class="string">"v@:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态处理方法</span></span><br><span class="line"><span class="keyword">void</span> a(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// implementation ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中class_addMethod的四个参数分别是：</p>
<ol>
<li>Class cls 给哪个类添加方法，本例中是self</li>
<li>SEL name 添加的方法，本例中是重写的拦截调用传进来的selector。</li>
<li>IMP imp 方法的实现，C方法的方法实现可以直接获得。如果是OC方法，可以用+ (IMP)instanceMethodForSelector:(SEL)aSelector;获得方法的实现。</li>
<li>“<code>v@:*</code>“方法的签名，代表有一个参数的方法。</li>
</ol>
<ul>
<li>forwardingTargetForSelector</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A.m</span></span><br><span class="line">- (id)<span class="string">forwardingTargetForSelector:</span>(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果代理对象能处理，则转接给代理对象</span></span><br><span class="line">    B *b = [[B alloc] init];</span><br><span class="line">    <span class="keyword">if</span> ([b <span class="string">respondsToSelector:</span>aSelector]) &#123;</span><br><span class="line">        <span class="keyword">return</span> proxyObj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不能处理进入转发流程</span></span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B.m</span></span><br><span class="line">- (<span class="typename">void</span>)b&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>也找不到能够帮忙处理这条未知消息，那就会走到最后一步</p>
<ul>
<li>forwardInvocation &amp; methodSignatureForSelector</li>
</ul>
<p>调用<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>，在调用forwardInvocation:之前会调用<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>方法来获取这个选择子的方法签名，然后在<code>-(void)forwardInvocation:(NSInvocation *)anInvocation</code>方法中你就可以通过anInvocation拿到相应信息做处理，实例代码如下</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当A类 收到一条`c`的消息的时候，前两步发现都没办法处理掉，走到第三步：</span></span><br><span class="line"><span class="comment">//A.m</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"forwardInvocation: %@"</span>, <span class="built_in">NSStringFromSelector</span>([anInvocation selector]));</span><br><span class="line">    <span class="keyword">if</span> ([anInvocation selector] == <span class="keyword">@selector</span>(c)) &#123;</span><br><span class="line">        C *c = [[C alloc] init];</span><br><span class="line">        [anInvocation invokeWithTarget:c];</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"method signature for selector: %@"</span>, <span class="built_in">NSStringFromSelector</span>(aSelector));</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(c)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">"V@:@"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C.m</span></span><br><span class="line">- (<span class="keyword">void</span>)c&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>消息转发流程如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/8/8/a65b266e187329db430c8120aab53ffc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>那么最后消息未能处理的时候，还会调用到<br><code>- (void)doesNotRecognizeSelector:(SEL)aSelector</code>这个方法，我们也可以在这个方法中做些文章，避免掉crash，但是只建议在线上环境的时候做处理，实际开发过程中还要把异常抛出来</p>
<h4 id="isa、Class_和_MetaClass">isa、Class 和 MetaClass</h4><p>Objective-C 是 C 的超集，提供了面向对象的机制，而面向对象思想里有两个重要的概念：类和实例</p>
<p>在 runtime.h 中我们可以看到如下定义：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_<span class="built_in">AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#if !__OBJC2__</span></span><br><span class="line">    Class super_class                                        OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="comment">/* Use `Class` instead of `struct objc_class *` */</span></span><br></pre></td></tr></table></figure></p>
<p>isa：是一个Class 类型的指针. 每个实例对象有个isa的指针, 它<code>指向对象的类</code>，而Class里也有个isa的指针, 指向metaClass(元类)。<br>元类也有isa指针,它的isa指针最终指向的是一个根元类(root metaClass).根元类的isa指针指向本身，这样形成了一个封闭的内循环。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//B.h</span></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">B</span>: NSObject</span><br><span class="line"></span><br><span class="line">+ (void)classFuncB;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//A.h</span></span><br><span class="line">#import <span class="string">"B.h"</span></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">A</span>: B</span><br><span class="line"></span><br><span class="line">+ (void)classFuncA;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line">#import <span class="string">"A.m"</span></span><br><span class="line"></span><br><span class="line">A *a = [[A alloc] init];</span><br><span class="line"><span class="comment">//此时a的isa指向类A(Class A)</span></span><br><span class="line"><span class="comment">//类A的isa指向类A的metaClass，类A的metaClass储存着类方法`classFuncA`</span></span><br><span class="line"></span><br><span class="line"><span class="attr_selector">[A classFuncB]</span>;</span><br><span class="line"><span class="comment">//此时类A调用类方法`classFuncB`, 但类A的metaClass找不到`classFuncB`, 则会去A的父类B的metaClass里找到`classFuncB`，</span></span><br></pre></td></tr></table></figure>
<p>继承关系：</p>
<ol>
<li>类继承（Class）：<code>A--&gt;B--&gt;NSObject--&gt;nil</code></li>
<li>元类继承 （MetaClass）：<code>MetaA--&gt;MetaB--&gt;RootMeta--&gt;NSObject(Class)--&gt;nil</code></li>
<li>isa继承：<code>实例a的isa--&gt;类A的isa--&gt;元类A的isa--&gt;RootMeta(根元类)的isa--&gt;RootMeta(根元类)自身的isa</code>, 类B同理。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/449095-3e972ec16703c54d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240/q/100" alt=""></p>
<ul>
<li><p>每一个对象本质上都是一个类的实例。其中类定义了成员变量和成员方法的列表。对象通过对象的isa指针指向类。</p>
</li>
<li><p>每一个类本质上都是一个对象，类其实是元类（metaClass）的实例。元类定义了类方法的列表。类通过类的isa指针指向元类。</p>
</li>
<li><p>所有的元类最终继承一个根元类，根元类isa指针指向本身，形成一个封闭的内循环。</p>
</li>
</ul>
<p>元类保存了<code>类方法</code>的列表。当类方法被调用时，先会从本身查找类方法的实现，如果没有，元类会向他父类查找该方法。</p>
<h4 id="load与initialize">load与initialize</h4><table>
<thead>
<tr>
<th></th>
<th>+ load</th>
<th>+ initialize</th>
</tr>
</thead>
<tbody>
<tr>
<td>调用时机</td>
<td>被添加到 runtime 时, 通常就是App启动时进行加载</td>
<td>收到第一条消息前(主动使用该类时)，可能永远不调用</td>
</tr>
<tr>
<td>调用顺序</td>
<td>父类-&gt;子类-&gt;分类</td>
<td>父类-&gt;子类</td>
</tr>
<tr>
<td>调用次数</td>
<td>1次</td>
<td>多次</td>
</tr>
<tr>
<td>是否需要显式调用父类实现</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>是否沿用父类的实现</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>分类中的实现</td>
<td>类和分类都执行</td>
<td>覆盖类中的方法，只执行分类的实现</td>
</tr>
<tr>
<td>常见应用</td>
<td>runtime method swizzling</td>
<td>可用来做一些初始化工作，如单例模式。</td>
</tr>
</tbody>
</table>
<h4 id="method_swizzling">method swizzling</h4><p>注意点：</p>
<ul>
<li>需要在<code>+(void)load</code>方法里</li>
<li>使用<code>dispatch_once</code>只交换一次</li>
</ul>
<p>示例：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">swizzling</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//load方法会在类第一次加载的时候被调用</span></span><br><span class="line"><span class="comment">//调用的时间比较靠前，适合在这个方法里做方法交换</span></span><br><span class="line">+ (<span class="keyword">void</span>)load&#123;</span><br><span class="line">    <span class="comment">//方法交换应该被保证，在程序中只会执行一次</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">//获得viewController的生命周期方法的selector</span></span><br><span class="line">        SEL systemSel = <span class="keyword">@selector</span>(viewWillAppear:);</span><br><span class="line">        <span class="comment">//自己实现的将要被交换的方法的selector</span></span><br><span class="line">        SEL swizzSel = <span class="keyword">@selector</span>(swiz_viewWillAppear:);</span><br><span class="line">        <span class="comment">//两个方法的Method</span></span><br><span class="line">        Method systemMethod = class_getInstanceMethod([<span class="keyword">self</span> class], systemSel);</span><br><span class="line">        Method swizzMethod = class_getInstanceMethod([<span class="keyword">self</span> class], swizzSel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//首先动态添加方法，实现是被交换的方法，返回值表示添加成功还是失败</span></span><br><span class="line">        <span class="built_in">BOOL</span> isAdd = class_addMethod(<span class="keyword">self</span>, systemSel, method_getImplementation(swizzMethod), method_getTypeEncoding(swizzMethod));</span><br><span class="line">        <span class="keyword">if</span> (isAdd) &#123;</span><br><span class="line">            <span class="comment">//如果成功，说明类中不存在这个方法的实现</span></span><br><span class="line">            <span class="comment">//将被交换方法的实现替换到这个并不存在的实现</span></span><br><span class="line">            class_replaceMethod(<span class="keyword">self</span>, swizzSel, method_getImplementation(systemMethod), method_getTypeEncoding(systemMethod));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//否则，交换两个方法的实现</span></span><br><span class="line">            method_exchangeImplementations(systemMethod, swizzMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)swiz_viewWillAppear:(<span class="built_in">BOOL</span>)animated&#123;</span><br><span class="line">    <span class="comment">//这时候调用自己，看起来像是死循环</span></span><br><span class="line">    <span class="comment">//但是其实自己的实现已经被替换了</span></span><br><span class="line">    [<span class="keyword">self</span> swiz_viewWillAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"swizzle"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<h4 id="关联对象AssociatedObject">关联对象AssociatedObject</h4><p>常用于对象动态添加属性</p>
<ul>
<li>用给定的key和policy来为指定对象(object)设置关联对象值(value)</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key, id <span class="keyword">value</span>, objc_AssociationPolicy policy</span>)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>根据给定的key从指定对象(object)中获取相对应的关联对象值</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br></pre></td></tr></table></figure>
<ul>
<li>移除指定对象的全部关联对象</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="title">objc_removeAssociatedObjects</span><span class="params">(id object)</span></span></span><br></pre></td></tr></table></figure>
<p>注意点：</p>
<ul>
<li><code>*key</code>:使用<code>static char kAssociatedObjectKey</code> (&amp;kAssociatedObjectKey) 或者 @selector(associatedObject)／<code>_cmd</code></li>
</ul>
<p>示例: 为UITableView增加一个属性cellHeight</p>
<ul>
<li><code>AssociationPolicy</code>:</li>
</ul>
<p>定义</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>, //给关联对象指定弱引用,相当于@<span class="keyword">property</span><span class="title"></span>(assign)或@<span class="keyword">property</span><span class="title"></span>(unsafe_unretained)</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, //给关联对象指定非原子的强引用,相当于@<span class="keyword">property</span><span class="title"></span>(nonatomic,strong)或@<span class="keyword">property</span><span class="title"></span>(nonatomic,retain)</span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>, //给关联对象指定非原子的copy特性,相当于@<span class="keyword">property</span><span class="title"></span>(nonatomic,copy)</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>, //给关联对象指定原子强引用,相当于@<span class="keyword">property</span><span class="title"></span>(atomic,strong)或@<span class="keyword">property</span><span class="title"></span>(atomic,retain)</span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span> //给关联对象指定原子copy特性,相当于@<span class="keyword">property</span><span class="title"></span>(atomic,copy)</span><br><span class="line">&#125;;</span><br><span class="line">typedef uintptr_t objc_AssociationPolicy;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UITableView+Height.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UITableView</span> (<span class="title">Height</span>)</span></span><br><span class="line"><span class="comment">/** height */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> cellHeight;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//UITableView+Height.m</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"UITableView+HeightManager.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UITableView</span> (<span class="title">Height</span>)</span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)setCellHeight:(<span class="built_in">CGFloat</span>)cellHeight &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(cellHeight), @(cellHeight), OBJC_ASSO<span class="built_in">CIATION_ASSIGN_NONATOMIC</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)cellHeight &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> * number = objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">    <span class="keyword">return</span> number<span class="variable">.floatValue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>_cmd</code>在Objective-C的方法中表示当前方法的selector</p>
</blockquote>
<h4 id="遍历类中的所有成员变量_class_copyIvarList">遍历类中的所有成员变量 class_copyIvarList</h4><p>有时候我们要对一些信息进行归档，如用户信息类UserInfo，这将需要重写initWithCoder和encodeWithCoder方法，并对每个属性进行encode和decode操作。那么问题来了：当属性只有几个的时候可以轻松写完，如果有几十个属性呢？我们可以 用runtime提供的函数遍历Model自身所有属性，并对属性进行encode和decode操作。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount;</span><br><span class="line">        <span class="comment">//获得所传入类的成员变量</span></span><br><span class="line">        Ivar *ivars = class_copyIvarList([<span class="keyword">self</span> class], &amp;outCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">            Ivar ivar = ivars[i];</span><br><span class="line">            <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">            [<span class="keyword">self</span> setValue:[aDecoder decodeObjectForKey:key] forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">        free(ivars);<span class="comment">//别忘记释放</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount;</span><br><span class="line">    Ivar *ivars = class_copyIvarList([<span class="keyword">self</span> class], &amp;outCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">        Ivar ivar = ivars[i];</span><br><span class="line">        <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">        [aCoder encodeObject:[<span class="keyword">self</span> valueForKey:key] forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同理，字典转模型用的也是这种方法。</p>
</blockquote>
<h4 id="访问苹果私有属性_class_copyPropertyList">访问苹果私有属性 class_copyPropertyList</h4><p>利用runtime获取私有属性名</p>
<p>假设我们有一个需求，想改变输入框中占位文字的颜色，用runtime的这个作用可以让我们很方便的实现：</p>
<p>先将输入框所包含的属性打印出来：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)getProperties &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">objc_property_t</span> *properties = class_copyPropertyList([UITextField <span class="keyword">class</span>], &amp;count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">        <span class="comment">// 取出属性</span></span><br><span class="line">        <span class="keyword">objc_property_t</span> property = properties[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印属性名字</span></span><br><span class="line">        NSLog(@<span class="string">"%s   &lt;----&gt;   %s"</span>, property_getName(property), property_getAttributes(property));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到这样一个属性：<br><img src="http://static.open-open.com/lib/uploadImg/20161218/20161218094612_594.png" alt=""></p>
<p>顾名思义，这就是占位的Label，我们只要利用KVC就可以将其改成我们想要的样子：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">self</span> <span class="built_in">set</span>Value:[UIColor whiteColor] <span class="keyword">for</span>KeyPath:@<span class="string">"_placeholderLabel.textColor"</span>];</span><br></pre></td></tr></table></figure>
<h4 id="类簇Class_Clusters与runtime">类簇Class Clusters与runtime</h4><p>类簇是抽象工厂模式在iOS下的一种实现，众多常用类，如NSString，NSArray，NSDictionary，NSNumber都运作在这一模式下，它是接口简单性和扩展性的权衡体现，在我们完全不知情的情况下，偷偷隐藏了很多具体的实现类，只暴露出简单的接口。而利用runtime的NSClassFromString可以动态地实现类簇应用。</p>
<h6 id="runtime–NSClassFromString_结合类簇应用示例">runtime–NSClassFromString 结合类簇应用示例</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要求实现：iOS7显示私有类A的viewA，iOS8-10显示私有类B的viewB，iOS11显示私有类C的viewC</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClusterView</span> : <span class="title">UIView</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在ClusterView.m里创建3个私有类：ViewA、ViewB、ViewC</span></span><br><span class="line"><span class="comment">//ClustersView.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClusterView</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.常规方法：在ClusterView.m中重写alloc的方法</span></span><br><span class="line">+ (instancetype)alloc&#123;</span><br><span class="line">    <span class="keyword">if</span>([<span class="keyword">self</span> class] == [ClusterView class]) &#123;</span><br><span class="line">        <span class="keyword">float</span> v = [[[<span class="built_in">UIDevice</span> currentDevice] systemVersion] floatValue];</span><br><span class="line">        <span class="keyword">if</span>(v &lt;= <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="comment">//iOS7</span></span><br><span class="line">            <span class="keyword">return</span> [ViewA alloc];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(v &gt;= <span class="number">8</span> &amp;&amp; v &lt;= <span class="number">10</span> ) &#123;</span><br><span class="line">            <span class="comment">//iOS8-10</span></span><br><span class="line">            <span class="keyword">return</span> [ViewB alloc];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//iOS11</span></span><br><span class="line">            <span class="keyword">return</span> [ViewC alloc];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> alloc];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.利用runtime，重写init方法</span></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">float</span> v = [[[<span class="built_in">UIDevice</span> currentDevice] systemVersion] floatValue];</span><br><span class="line">        <span class="built_in">NSString</span> *className = <span class="string">@"ViewC"</span>;</span><br><span class="line">        <span class="keyword">if</span>(v &lt;= <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="comment">//iOS7</span></span><br><span class="line">            className = <span class="string">@"ViewA"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(v &gt;= <span class="number">8</span> &amp;&amp; v &lt;= <span class="number">10</span> ) &#123;</span><br><span class="line">            <span class="comment">//iOS8-10</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"ViewB"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Class class = <span class="built_in">NSClassFromString</span>(className);</span><br><span class="line">        <span class="keyword">self</span> = [[class alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for iOS7</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewA</span> : <span class="title">ClusterView</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewA</span></span></span><br><span class="line">- (<span class="keyword">void</span>)drawRect: (<span class="built_in">CGRect</span>)rect&#123;</span><br><span class="line">    <span class="comment">/* Custom iOS7 drawing code */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for iOS8-10</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewB</span> : <span class="title">ClusterView</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewB</span></span></span><br><span class="line">- (<span class="keyword">void</span>)drawRect: (<span class="built_in">CGRect</span>)rect&#123;</span><br><span class="line">    <span class="comment">/* Custom iOS8-11 drawing code */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for iOS11</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewC</span> : <span class="title">ClusterView</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewC</span></span></span><br><span class="line">- (<span class="keyword">void</span>)drawRect: (<span class="built_in">CGRect</span>)rect&#123;</span><br><span class="line">    <span class="comment">/* Custom iOS11 drawing code */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h6 id="参考资料">参考资料</h6><blockquote>
<p><a href="https://juejin.im/entry/59888a8d6fb9a03c5e4408a3" target="_blank" rel="external">https://juejin.im/entry/59888a8d6fb9a03c5e4408a3</a><br><a href="https://github.com/maligh/ML-Objective-C-Demo/blob/master/MessageForwarding" target="_blank" rel="external">https://github.com/maligh/ML-Objective-C-Demo/blob/master/MessageForwarding</a><br><a href="http://blog.csdn.net/yst19910702/article/details/51443901" target="_blank" rel="external">http://blog.csdn.net/yst19910702/article/details/51443901</a><br><a href="https://www.jianshu.com/p/8036f15c91c6" target="_blank" rel="external">https://www.jianshu.com/p/8036f15c91c6</a><br><a href="http://blog.devzeng.com/blog/ios-class-cluster-design-pattern.html" target="_blank" rel="external">http://blog.devzeng.com/blog/ios-class-cluster-design-pattern.html</a><br><a href="http://www.cocoachina.com/ios/20150104/10826.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20150104/10826.html</a><br><a href="http://nshipster.com/method-swizzling/" target="_blank" rel="external">http://nshipster.com/method-swizzling/</a><br><a href="http://nshipster.com/associated-objects/" target="_blank" rel="external">http://nshipster.com/associated-objects/</a><br><a href="http://blog.devzeng.com/blog/oc-associated-objects.html" target="_blank" rel="external">http://blog.devzeng.com/blog/oc-associated-objects.html</a><br><a href="https://www.jianshu.com/p/872447c6dc3f" target="_blank" rel="external">https://www.jianshu.com/p/872447c6dc3f</a></p>
</blockquote>

      

      

    </div>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/05/07/Runloop/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Runloop
        
      </div>
    </a>
  
  
    <a href="/2017/03/04/Timer/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Timer</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src='https://imsun.github.io/gitment/dist/gitment.browser.js'></script>
  <script>
    var gitment = new Gitment({
      id: 'Mon Mar 06 2017 20:32:31 GMT+0800',
      owner: 'litt1e-p',
      repo: 'litt1e-p.github.io',
      oauth: {
        client_id: '9c322023e341566fda8e',
        client_secret: '2f7e965734d39f19928f7bd3d1a77f9b8f032837',
      },
    })
    gitment.render('comments')
  </script>
</section>

</section>
        <aside id="sidebar">
  <nav class="menus">
  	<ul>
  		<li><a href="/"><i class="icon icon-home"></i></a></li>
  		
			<li><a href="/archives"><i class="icon icon-fenlei"></i></a></li>
  		
  		
			<li><a href="/tags"><i class="icon icon-tag"></i></a></li>
  		
  		
  			<li><a href="https://github.com/litt1e-p" target="_blank"><i class="icon icon-github"></i></a></li>
  		
  	</ul>
  </nav>
  <a id="go-top" href="#"><i class="icon icon-up"></i></a>
</aside>

      </div>
      <footer id="footer">
  
	<div id="footer-info" class="inner">
	  &copy; 2020 litt1e-p 
	  - Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	  - Theme <a href="https://github.com/hejianxian/hexo-theme-jane/" target="_blank">Jane</a>
	</div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/tags" class="mobile-nav-link">Tag</a>
  
    <a href="https://github.com/litt1e-p" class="mobile-nav-link">Github</a>
  
</nav>
    
<script>
  var disqus_shortname = 'litt1ep';
  
  var disqus_url = 'https://litt1e-p.github.io/2017/03/06/Runtime/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>