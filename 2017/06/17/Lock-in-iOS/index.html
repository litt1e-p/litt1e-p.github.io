<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Lock in iOS | litt1e-p</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="iOS锁死锁一个示例12345678- (void)run &amp;#123;    NSLog(@&quot;1&quot;);    //主队列的同步线程，按照FIFO的原则（先入先出），2排在3后面会等3执行完，但因为同步线程，3又要等2执行完，相互等待成为死锁。    dispatch_sync(dispatch_get_main_queue(), ^&amp;#123;        NSLog(@&quot;2&quot;);    &amp;#">
<meta property="og:type" content="article">
<meta property="og:title" content="Lock in iOS">
<meta property="og:url" content="https://litt1e-p.github.io/2017/06/17/Lock-in-iOS/index.html">
<meta property="og:site_name" content="litt1e-p">
<meta property="og:description" content="iOS锁死锁一个示例12345678- (void)run &amp;#123;    NSLog(@&quot;1&quot;);    //主队列的同步线程，按照FIFO的原则（先入先出），2排在3后面会等3执行完，但因为同步线程，3又要等2执行完，相互等待成为死锁。    dispatch_sync(dispatch_get_main_queue(), ^&amp;#123;        NSLog(@&quot;2&quot;);    &amp;#">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/8/1603542bc602d97f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:updated_time" content="2018-03-07T12:06:21.094Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lock in iOS">
<meta name="twitter:description" content="iOS锁死锁一个示例12345678- (void)run &amp;#123;    NSLog(@&quot;1&quot;);    //主队列的同步线程，按照FIFO的原则（先入先出），2排在3后面会等3执行完，但因为同步线程，3又要等2执行完，相互等待成为死锁。    dispatch_sync(dispatch_get_main_queue(), ^&amp;#123;        NSLog(@&quot;2&quot;);    &amp;#">
  
    <link rel="alternative" href="/atom.xml" title="litt1e-p" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <section id="main"><article id="post-Lock-in-iOS" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Lock in iOS
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/06/17/Lock-in-iOS/" class="article-date">
  <time datetime="2017-06-17T02:05:08.000Z" itemprop="datePublished">2017-06-17</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="iOS锁">iOS锁</h2><h4 id="死锁">死锁</h4><p>一个示例<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)run &#123;</span><br><span class="line">    <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"1"</span>);</span></span><br><span class="line">    <span class="comment">//主队列的同步线程，按照FIFO的原则（先入先出），2排在3后面会等3执行完，但因为同步线程，3又要等2执行完，相互等待成为死锁。</span></span><br><span class="line">    <span class="function">dispatch_sync</span>(<span class="function">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">        <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"2"</span>);</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"3"</span>);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出1之后发生死锁，sync到当前主线程(串行队列)的block将会引起死锁。原因是dispatch_sync将一个block插入到main queue中，sync会等待到这个block执行完成后才返回继续执行(async则不会等待)，而这个block的执行还等待着run中dispatch_sync调用的结束，所以造成了循环等待，导致死锁。</p>
<h4 id="互斥锁POSIX">互斥锁POSIX</h4><p>POSIX和<code>dispatch_semaphore_t</code>很像，但是完全不同。POSIX是Unix/Linux平台上提供的一套条件互斥锁的API。<br>为了锁住和解锁一个互斥锁，你可以使用<code>pthread_mutex_lock</code>和<code>pthread_mutex_unlock</code>函数。当你用完一个锁之后，只要简单的调用<code>pthread_mutex_destroy</code>来释放该锁的数据结构。<br>互斥锁提供了三个函数，从函数名就可以知道他们的作用：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(pthread_mutex_t *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(pthread_mutex_t *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(pthread_mutex_t *mutex)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>函数<code>pthread_mutex_trylock</code>和<code>pthread_mutex_lock</code>的功能相似，只不过前者在获取锁失败的情况下会立即返回，而后者则会一直阻塞在那里直到获取到锁为止<br>。</p>
<p>举例<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">POSIXViewController</span> () </span>&#123;</span><br><span class="line">    pthread_mutex_t mutex;  <span class="comment">//声明pthread_mutex_t的结构</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">POSIXViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);  <span class="comment">//释放该锁的数据结构</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  初始化</span><br><span class="line">     *</span><br><span class="line">     */</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)getImageName:(<span class="built_in">NSMutableArray</span> *)imageNames &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *imageName;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  加锁</span><br><span class="line">     */</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span> (imageNames<span class="variable">.count</span>&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        imageName = [imageNames firstObject];</span><br><span class="line">        [imageNames removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  解锁</span><br><span class="line">     */</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>POSIX还可以创建条件锁，提供了和NSCondition一样的条件控制，初始化互斥锁同时使用pthread_cond_init来初始化条件数据结构，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span> <span class="params">(pthread_cond_t *cond, pthread_condattr_t *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待（会阻塞）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span> <span class="params">(pthread_cond_t *cond, pthread_mutex_t *mut)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span> <span class="params">(pthread_cond_t *cond, pthread_mutex_t *mut, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *abstime)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span> <span class="params">(pthread_cond_t *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span> <span class="params">(pthread_cond_t *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span> <span class="params">(pthread_cond_t *cond)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="互斥锁NSLock">互斥锁NSLock</h4><p>NSLock中实现了一个简单的互斥锁。所有锁（包括NSLock）的接口实际上都是通过NSLocking协议定义的，它定义了lock和unlock方法。你使用这些方法来获取和释放该锁。NSLock类使用的是POSIX线程来实现它的锁操作。</p>
<p>NSLock不能被用来实现迭代锁，因为如果发生lock消息两次的话，整个线程将被永久锁住。</p>
<p>除了标准的锁行为，NSLock类还增加了tryLock和lockBeforeDate:方法。方法tryLock试图获取一个锁，但是如果锁不可用的时候，它不会阻塞线程。相反，它只是返回NO。而lockBeforeDate:方法试图获取一个锁，但是如果锁没有在规定的时间内被获得，它会让线程从阻塞状态变为非阻塞状态（或者返回NO）。</p>
<p>NSLock的执行原理：<br>某个线程A调用lock方法。这样，NSLock将被上锁。可以执行“关键部分”，完成后，调用unlock方法。如果，在线程A 调用unlock方法之前，另一个线程B调用了同一锁对象的lock方法。那么，线程B只有等待。直到线程A调用了unlock。</p>
<p>使用时，基本方法就是：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSLock *<span class="keyword">lock</span> = [[NSLock alloc] init];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">lock</span> <span class="keyword">lock</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">lock</span> unlock];</span><br></pre></td></tr></table></figure></p>
<p>此外，还可以为NSLock设置name：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)newName</span><br><span class="line">- (<span class="built_in">NSString</span> *)name <span class="comment">//返回锁指定的Name</span></span><br></pre></td></tr></table></figure></p>
<h4 id="指令@synchronized">指令@synchronized</h4><p>@synchronized是在Objective-C中最简单方法，只要有个Objective-C对象就可以完成线程同步操作。@synchronized指令做和其他互斥锁一样的工作（它防止不同的线程在同一时间获取同一个锁）。你不需要直接创建一个互斥锁或锁对象。相反，你只需要简单的使用Objective-C对象作为锁的令牌。需要注意的是，@synchronized会隐式地添加异常处理代码，也就是当发生异常时会自动释放互斥锁，所以会有一定的性能损耗。</p>
<p>示例：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)<span class="function"><span class="keyword">method</span>:</span>(id)anObj <span class="comment">&#123;</span><br><span class="line">    @synchronized(anObj) &#123;</span><br><span class="line">        // Everything between the braces is protected by the @synchronized directive.</span><br><span class="line">    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//swift 写法</span></span><br><span class="line">objc_sync_enter(<span class="keyword">self</span>)</span><br><span class="line"><span class="comment">//需要执行的代码块</span></span><br><span class="line">objc_sync_exit(<span class="keyword">self</span>)</span><br></pre></td></tr></table></figure></p>
<p>传给@synchronized指令的对象是用来区别保护块的唯一标示，如果你在两个不同的线程里面执行上述方法，每次在一个线程传递了一个不同的对象给anObj参数，那么每次都将会拥有它的锁，并持续处理，中间不被其他线程阻塞。然而，如果你传递的是<code>同一个对象</code>，那么多个线程中的一个线程会首先获得该锁，而其他线程将会被阻塞直到第一个线程完成。</p>
<p>作为一种预防措施，@synchronized块隐式的添加一个异常处理例程来保护代码。该处理例程会在异常抛出的时候自动的释放互斥锁。这意味着为了使用@synchronized指令，你必须在你的代码中启用异常处理。如果你不想让隐式的异常处理例程带来额外的开销，你应该考虑使用锁的类。</p>
<h4 id="GCD信号量锁_dispatch_semaphore_t和dispatch_semaphore_wait">GCD信号量锁 dispatch_semaphore_t和dispatch_semaphore_wait</h4><p>dispatch_semaphore 信号量基于计数器的一种多线程同步机制。dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); 如果semaphore计数大于等于1.计数－1，程序继续运行。如果计数为0，则等待。这里设置的等待时间是一直等待。dispatch_semaphore_signal(semaphore);计数＋1.在这两句代码中间的执行代码，每次只会允许一个线程进入，这样就有效的保证了在多线程环境下，只能有一个线程进入。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">//获取全局并发队列</span></span><br><span class="line"><span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">1</span>); <span class="comment">//创建信号量</span></span><br><span class="line">NSMutableArray *<span class="built_in">array</span> = [NSMutableArrayarray];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">100000</span>; index++) &#123;</span><br><span class="line">    dispatch_async(<span class="built_in">queue</span>, ^()&#123; <span class="comment">//并发队列里执行任务</span></span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); <span class="comment">// semaphore计数大于等于1.计数－1，程序继续运行。如果计数为0，则等待</span></span><br><span class="line">        NSLog(@<span class="string">"addd :%d"</span>, index);</span><br><span class="line">        [<span class="built_in">array</span> addObject:[NSNumber numberWithInt:index]];</span><br><span class="line">        dispatch_semaphore_signal(semaphore); <span class="comment">//计数＋1</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="递归锁_NSRecursiveLock">递归锁 NSRecursiveLock</h4><p>NSRecursiveLock这个锁可以被同一线程多次请求，而不会引起死锁。NSRecursiveLock通常被用在一个递归函数里面来防止递归造成阻塞线程，只有当多次获取的锁全部释放时，NSRecursiveLock才能被其他线程获取。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NSLock *<span class="keyword">lock</span> = [[NSLock alloc] init];</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">void</span> (<span class="params">^RecursiveMethod</span>)(<span class="params"><span class="keyword">int</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">    RecursiveMethod = ^(<span class="keyword">int</span> <span class="keyword">value</span>) &#123;</span><br><span class="line">        [<span class="keyword">lock</span> <span class="keyword">lock</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            NSLog(<span class="string">@"value = %d"</span>, <span class="keyword">value</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            RecursiveMethod(<span class="keyword">value</span> - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">lock</span> unlock];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    RecursiveMethod(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码是一个典型的死锁情况。在我们的线程中，RecursiveMethod是递归调用的。所以每次进入这个block时，都会去加一次锁，而从第二次开始，由于锁已经被使用了且没有解锁，所以它需要等待锁被解除，这样就导致了死锁，线程被阻塞住了。</p>
<p>在这种情况下，我们就可以使用NSRecursiveLock，只需要把<code>NSLock *lock = [[NSLock alloc] init];</code>改成<code>NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];</code>即可。</p>
<p>与NSLock一样，拥有<code>tryLock</code>和<code>lockBeforeDate:</code>及<code>setName</code>等方法</p>
<h4 id="条件锁_NSConditionLock">条件锁 NSConditionLock</h4><p>也有人说这是个互斥锁<br>NSConditionLock同样实现了NSLocking协议，试验过程中发现性能很低</p>
<p>示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个并发队列</span></span><br><span class="line">synchronizationQueue = dispatch_queue_create([@<span class="string">"com.mac.synchronization"</span> cStringUsingEncoding:NSASCIIStringEncoding], DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)remove:(NSMutableArray *)data &#123;</span><br><span class="line">    NSString *str;</span><br><span class="line">    [lock lockWhenCondition:<span class="number">1</span>];    <span class="comment">//条件加锁</span></span><br><span class="line">    <span class="keyword">if</span> (data.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        str = [data lastObject];</span><br><span class="line">        [data removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    [lock unlockWithCondition:<span class="number">0</span>];     <span class="comment">//改变条件解锁</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)add:(NSMutableArray *)data &#123;</span><br><span class="line">    [lock lockWhenCondition:<span class="number">0</span>]; <span class="comment">//条件加锁</span></span><br><span class="line">    [data addObject:@<span class="string">"0"</span>];</span><br><span class="line">    [lock unlockWithCondition:<span class="number">1</span>]; <span class="comment">//改变条件解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> mark - 多线程取出数据后删除</span></span><br><span class="line">- (<span class="keyword">void</span>)getDataInMultiThread &#123;</span><br><span class="line">    NSMutableArray *data = [NSMutableArray <span class="built_in">array</span>];</span><br><span class="line">    <span class="keyword">dispatch_group_t</span> dispatchGroup = dispatch_group_create();</span><br><span class="line">    __block <span class="keyword">double</span> then, now;</span><br><span class="line">    then = CFAbsoluteTimeGetCurrent();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">        dispatch_group_async(dispatchGroup, synchronizationQueue, ^()&#123;</span><br><span class="line">            [self remove:data];</span><br><span class="line">        &#125;);</span><br><span class="line">        dispatch_group_async(dispatchGroup, synchronizationQueue, ^()&#123;</span><br><span class="line">            [self add:data];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_group_notify(dispatchGroup, synchronizationQueue, ^()&#123;</span><br><span class="line">        now = CFAbsoluteTimeGetCurrent();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread_lock: %f sec\n data count: %ld\n"</span>, now-then, data.count);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>条件锁的初始状态是<code>&quot;0&quot;</code>，所以<code>add</code>线程在这个时候就会获取到锁，执行完成后再把状态设置为<code>&quot;1&quot;</code>；这时<code>remove</code>线程发现条件变成<code>&quot;1&quot;</code>后就可以获取到锁，直到执行结束后再把状态设置成<code>&quot;0&quot;</code>。</p>
<h4 id="条件锁与互斥锁结合体_NSCondition">条件锁与互斥锁结合体 NSCondition</h4><p>NSCondition类是互斥锁和条件锁的结合体，也就是一个线程在等待信号而阻塞时，可以被另外一个线程唤醒<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">NSCondition </span>*<span class="keyword">cond</span> = [[<span class="constant">NSCondition </span>alloc] init];</span><br><span class="line">[<span class="keyword">cond</span> lock];</span><br><span class="line"><span class="keyword">while</span> (timeToDoWork &lt;= <span class="number">0</span>)</span><br><span class="line">[<span class="keyword">cond</span> wait];</span><br><span class="line">timeToDoWork--;</span><br><span class="line"><span class="regexp">//</span> <span class="constant">Do </span>real work here.</span><br><span class="line">[<span class="keyword">cond</span> unlock];</span><br></pre></td></tr></table></figure></p>
<p>在其他线程中唤醒：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">[<span class="keyword"><span class="built_in">cond</span></span> lock]<span class="comment">;</span></span><br><span class="line">timeToDoWork++<span class="comment">;</span></span><br><span class="line"><span class="list">[<span class="keyword"><span class="built_in">cond</span></span> signal]<span class="comment">;</span></span><br><span class="line"><span class="list">[<span class="keyword"><span class="built_in">cond</span></span> unlock]<span class="comment">;</span></span></span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="互斥锁、跨进程的分布式锁_NSDistributedLock">互斥锁、跨进程的分布式锁 NSDistributedLock</h4><p>NSDistributedLock是MAC开发中的跨进程的分布式锁，底层是用文件系统实现的互斥锁。NSDistributedLock没有实现NSLocking协议，所以没有lock方法，取而代之的是非阻塞的tryLock方法。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSDistributedLock *<span class="keyword">lock</span> = [[NSDistributedLock alloc] initWithPath:<span class="string">@"/Users/mac/Desktop/lock.lock"</span>];</span><br><span class="line"><span class="keyword">while</span> (![<span class="keyword">lock</span> tryLock]) &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">[<span class="keyword">lock</span> unlock];</span><br></pre></td></tr></table></figure></p>
<p>NSDistributedLock只有在锁持有者显式地释放后才会被释放，也就是说当持有锁的应用崩溃后，其他应用就不能访问受保护的共享资源了。<br>如当执行到do something时程序退出,程序再次启动之后tryLock就再也不能成功了,陷入死锁状态.其他应用也不能访问受保护的共享资源。在这种情况下，你可以使用breadLock方法来打破现存的锁以便你可以获取它。但是通常应该避免打破锁，除非你确定拥有进程已经死亡并不可能再释放该锁。</p>
<h4 id="自旋锁OSSpinLock">自旋锁OSSpinLock</h4><p>首先要提的是OSSpinLock已经出现了BUG，导致并不能完全保证是线程安全的。</p>
<blockquote>
<p>新版 iOS 中，系统维护了 5 个不同的线程优先级/QoS: background，utility，default，user-initiated，user-interactive。高优先级线程始终会在低优先级线程前执行，一个线程不会受到比它更低优先级线程的干扰。这种线程调度算法会产生潜在的优先级反转问题，从而破坏了 spin lock。<br>具体来说，如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。这并不只是理论上的问题，libobjc 已经遇到了很多次这个问题了，于是苹果的工程师停用了 OSSpinLock。<br>苹果工程师 Greg Parker 提到，对于这个问题，一种解决方案是用 truly unbounded backoff 算法，这能避免 livelock 问题，但如果系统负载高时，它仍有可能将高优先级的线程阻塞数十秒之久；另一种方案是使用 handoff lock 算法，这也是 libobjc 目前正在使用的。锁的持有者会把线程 ID 保存到锁内部，锁的等待者会临时贡献出它的优先级来避免优先级反转的问题。理论上这种模式会在比较复杂的多锁条件下产生问题，但实践上目前还一切都好。<br>OSSpinLock 自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。对于内存缓存的存取来说，它非常合适。<br>-摘自<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="external">ibireme-不再安全的 OSSpinLock</a></p>
</blockquote>
<p>示例：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#import &lt;libkern/OSAtomic.h&gt;</span></span><br><span class="line"><span class="comment">@interface OSSpinLockViewController () &#123;</span></span><br><span class="line">    OSSpinLock spinlock;  //声明pthread_mutex_t的结构</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">@implementation OSSpinLockViewController</span></span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    /<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">     <span class="keyword">*</span>  初始化</span><br><span class="line">     <span class="keyword">*</span></span><br><span class="line">     <span class="keyword">*</span>/</span><br><span class="line">    spinlock = OS_SPINLOCK_INIT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)run &#123;</span><br><span class="line">    /<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">     <span class="keyword">*</span>  加锁</span><br><span class="line">     <span class="keyword">*</span>/</span><br><span class="line">    OSSpinLockLock(&amp;spinlock);</span><br><span class="line">    //do something</span><br><span class="line">    /<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">     <span class="keyword">*</span>  解锁</span><br><span class="line">     <span class="keyword">*</span>/</span><br><span class="line">    OSSpinLockUnlock(&amp;spinlock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">@end</span></span><br></pre></td></tr></table></figure></p>
<p>iOS 10 之后，苹果给出了解决方案，就是用 os_unfair_lock 代替 OSSpinLock</p>
<p><code>&#39;OSSpinLockLock&#39; is deprecated: first deprecated in iOS 10.0 - Use os_unfair_lock_lock() from &lt;os/lock.h&gt; instead</code></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;os/lock.h&gt;</span><br><span class="line"></span><br><span class="line">__block os_unfair_lock lock = OS_UNFAIR_LOCK_INIT<span class="comment">;</span></span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">   os_unfair_lock_lock(&amp;lock)<span class="comment">;</span></span><br><span class="line">   NSLog(@"第一个线程同步操作开始")<span class="comment">;</span></span><br><span class="line">   sleep(8)<span class="comment">;</span></span><br><span class="line">   NSLog(@"第一个线程同步操作结束")<span class="comment">;</span></span><br><span class="line">   os_unfair_lock_unlock(&amp;lock)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">   sleep(1)<span class="comment">;</span></span><br><span class="line">   os_unfair_lock_lock(&amp;lock)<span class="comment">;</span></span><br><span class="line">   NSLog(@"第二个线程同步操作开始")<span class="comment">;</span></span><br><span class="line">   os_unfair_lock_unlock(&amp;lock)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">//执行结果</span><br><span class="line">//<span class="number">2017-11-30</span> <span class="number">15:12:31.70</span><span class="number">1180+0800</span> 第一个线程同步操作开始</span><br><span class="line">//<span class="number">2017-11-30</span> <span class="number">15:12:39.70</span><span class="number">5473+0800</span> 第一个线程同步操作结束</span><br><span class="line">//<span class="number">2017-11-30</span> <span class="number">15:12:39.70</span><span class="number">5820+0800</span> 第二个线程同步操作开始</span><br></pre></td></tr></table></figure>
<p>自旋锁和互斥锁异同</p>
<p>相同点：都能保证同一时间只有一个线程访问共享资源。都能保证线程安全。</p>
<p>不同点：</p>
<p>互斥锁：如果共享数据已经有其他线程加锁了，线程会进入休眠状态等待锁。一旦被访问的资源被解锁，则等待资源的线程会被唤醒。</p>
<p>自旋锁：如果共享数据已经有其他线程加锁了，线程会以死循环的方式等待锁，一旦被访问的资源被解锁，则等待资源的线程会立即执行。</p>
<p>自旋锁的效率高于互斥锁。</p>
<h4 id="GCD线程阻断dispatch_barrier_async/dispatch_barrier_sync">GCD线程阻断dispatch_barrier_async/dispatch_barrier_sync</h4><p>dispatch_barrier_async/dispatch_barrier_sync在一定的基础上也可以做线程同步，会在线程队列中打断其他线程执行当前任务，也就是说<code>只有用在并发的线程队列中</code>才会有效，因为串行队列本来就是一个一个的执行的，你打断执行一个和插入一个是一样的效果。两个的区别是是否等待任务执行完成。</p>
<blockquote>
<p>注意：如果在当前线程调用dispatch_barrier_sync打断会发生死锁。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">__block <span class="keyword">double</span> then, now;</span><br><span class="line"><span class="comment">//创建一个并发队列</span></span><br><span class="line">synchronizationQueue = dispatch_queue_create([@<span class="string">"com.mac.synchronization"</span> cStringUsingEncoding:NSASCIIStringEncoding], DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)getData:(NSMutableArray *)data &#123;</span><br><span class="line">    NSString *str;</span><br><span class="line">    <span class="keyword">if</span> (data.count&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        str = [data firstObject];</span><br><span class="line">        [data removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        now = CFAbsoluteTimeGetCurrent();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread_lock: %f sec\n data count: %ld\n"</span>, now-then, data.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)getDataWithMultiThread &#123;</span><br><span class="line">    NSMutableArray *data = [NSMutableArray <span class="keyword">new</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1024</span>*<span class="number">11</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">        [data addObject:[NSString stringWithFormat:@<span class="string">"%d"</span>, i]];</span><br><span class="line">    &#125;</span><br><span class="line">    then = CFAbsoluteTimeGetCurrent();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//100来测试锁有没有正确的执行</span></span><br><span class="line">        dispatch_barrier_async(synchronizationQueue, ^&#123;</span><br><span class="line">             [self getData:data];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="各种锁性能">各种锁性能</h4><p><img src="https://user-gold-cdn.xitu.io/2017/12/8/1603542bc602d97f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h4 id="总结">总结</h4><ul>
<li><code>POSIX</code>(pthread_mutex)：底层的api，复杂的多线程处理建议使用，并且可以封装自己的多线程</li>
<li><code>@synchronized</code>：适用线程不多，任务量不大的多线程加锁</li>
<li><code>NSLock</code>：其实NSLock并没有想象中的那么差，不知道大家为什么不推荐使用</li>
<li><code>dispatch_semaphore_t</code>：使用信号来做加锁，性能提升显著</li>
<li><code>NSCondition</code>：使用其做多线程之间的通信调用不是线程安全的</li>
<li><code>NSConditionLock</code>：单纯加锁性能非常低，比NSLock低很多，但是可以用来做多线程处理不同任务的通信调用</li>
<li><code>NSRecursiveLock</code>：递归锁的性能出奇的高，但是只能作为递归使用,所以限制了使用场景</li>
<li><code>NSDistributedLock</code>：因为是MAC开发的，就不讨论了</li>
<li><code>OSSpinLock</code>：性能也非常高，可惜出现了线程不安全问题，使用 os_unfair_lock 来代替</li>
<li><code>dispatch_barrier_async/dispatch_barrier_sync</code>：测试中发现dispatch_barrier_sync比dispatch_barrier_async性能要高</li>
</ul>
<h6 id="参考资料">参考资料</h6><blockquote>
<p><a href="https://www.jianshu.com/p/35dd92bcfe8c" target="_blank" rel="external">https://www.jianshu.com/p/35dd92bcfe8c</a><br><a href="http://www.bijishequ.com/detail/354750" target="_blank" rel="external">http://www.bijishequ.com/detail/354750</a><br><a href="https://github.com/YasinZhou/ThreadLockDemo" target="_blank" rel="external">https://github.com/YasinZhou/ThreadLockDemo</a></p>
</blockquote>

      

      

    </div>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/08/25/Build-a-git-repo-server/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Build a git repo server
        
      </div>
    </a>
  
  
    <a href="/2017/05/07/Runloop/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Runloop</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src='https://imsun.github.io/gitment/dist/gitment.browser.js'></script>
  <script>
    var gitment = new Gitment({
      owner: 'litt1e-p',
      repo: 'litt1e-p.github.io',
      oauth: {
        client_id: '9c322023e341566fda8e',
        client_secret: '2f7e965734d39f19928f7bd3d1a77f9b8f032837',
      },
    })
    gitment.render('comments')
  </script>
</section>

</section>
        <aside id="sidebar">
  <nav class="menus">
  	<ul>
  		<li><a href="/"><i class="icon icon-home"></i></a></li>
  		
			<li><a href="/archives"><i class="icon icon-fenlei"></i></a></li>
  		
  		
			<li><a href="/tags"><i class="icon icon-tag"></i></a></li>
  		
  		
  			<li><a href="https://github.com/litt1e-p" target="_blank"><i class="icon icon-github"></i></a></li>
  		
  	</ul>
  </nav>
  <a id="go-top" href="#"><i class="icon icon-up"></i></a>
</aside>

      </div>
      <footer id="footer">
  
	<div id="footer-info" class="inner">
	  &copy; 2018 litt1e-p 
	  - Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	  - Theme <a href="https://github.com/hejianxian/hexo-theme-jane/" target="_blank">Jane</a>
	</div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/tags" class="mobile-nav-link">Tag</a>
  
    <a href="https://github.com/litt1e-p" class="mobile-nav-link">Github</a>
  
</nav>
    
<script>
  var disqus_shortname = 'litt1ep';
  
  var disqus_url = 'https://litt1e-p.github.io/2017/06/17/Lock-in-iOS/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>